C:\Users\Anka\.conda\envs\Deform\python.exe "C:\Program Files\JetBrains\PyCharm Community Edition 2018.3.1\helpers\pydev\pydevd.py" --multiproc --qt-support=auto --client 127.0.0.1 --port 64096 --file C:/Code/MyRepo/ChbCapture/06_Deformation/MeshInterpolation/TestIglIter.py
pydev debugger: process 31640 is connecting

Connected to pydev debugger (build 183.4588.64)
Help on module pyigl:

NAME
    pyigl

DESCRIPTION
    Python wrappers for libigl
    --------------------------

    .. currentmodule:: pyigl

    .. autosummary::
       :toctree: _generate

       AABB
       ARAPEnergyType
       MeshBooleanType
       SolverStatus
       active_set
       adjacency_list
       arap
       avg_edge_length
       barycenter
       barycentric_coordinates
       barycentric_to_global
       bbw
       boundary_conditions
       boundary_facets
       boundary_loop
       cat
       collapse_edge
       colon
       column_to_quats
       comb_cross_field
       comb_frame_field
       compute_frame_field_bisectors
       copyleft_cgal_RemeshSelfIntersectionsParam
       copyleft_cgal_mesh_boolean
       copyleft_cgal_remesh_self_intersections
       copyleft_comiso_miq
       copyleft_comiso_nrosy
       copyleft_marching_cubes
       copyleft_swept_volume
       copyleft_tetgen_tetrahedralize
       cotmatrix
       covariance_scatter_matrix
       cross_field_missmatch
       cut_mesh_from_singularities
       deform_skeleton
       directed_edge_orientations
       directed_edge_parents
       doublearea
       dqs
       edge_lengths
       edge_topology
       eigs
       embree_ambient_occlusion
       embree_line_mesh_intersection
       embree_reorient_facets_raycast
       find_cross_field_singularities
       fit_rotations
       floor
       forward_kinematics
       gaussian_curvature
       get_seconds
       grad
       harmonic
       hsv_to_rgb
       internal_angles
       invert_diag
       is_irregular_vertex
       jet
       lbs_matrix
       local_basis
       lscm
       map_vertices_to_circle
       massmatrix
       min_quad_with_fixed
       normalize_row_lengths
       normalize_row_sums
       parula
       per_corner_normals
       per_edge_normals
       per_face_normals
       per_vertex_normals
       planarize_quad_mesh
       png_readPNG
       png_writePNG
       point_mesh_squared_distance
       polar_svd
       principal_curvature
       quad_planarity
       randperm
       readDMAT
       readMESH
       readOBJ
       readOFF
       readTGF
       read_triangle_mesh
       remove_duplicate_vertices
       rotate_vectors
       setdiff
       signed_distance
       slice
       slice_into
       slice_mask
       marching_tets
       sortrows
       streamlines
       triangle_triangle_adjacency
       triangle_triangulate
       unique
       unproject_onto_mesh
       upsample
       winding_number
       writeMESH
       writeOBJ
       writePLY
       readPLY

SUBMODULES
    comiso
    copyleft
    eigen
    embree
    glfw
    png
    tetgen
    triangle

CLASSES
    pybind11_builtins.pybind11_object(builtins.object)
        AABB
        ARAPData
        ARAPEnergyType
        BBWData
        EigsType
        MassMatrixType
        MeshBooleanType
        PerEdgeNormalsWeightingType
        PerVertexNormalsWeightingType
        RotationList
        SignedDistanceType
        SolverStatus
        VectorInt
        VectorVectorInt
        active_set_params
        min_quad_with_fixed_data

    class AABB(pybind11_builtins.pybind11_object)
     |  Method resolution order:
     |      AABB
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(...)
     |      __init__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __init__(self: pyigl.AABB) -> None
     |
     |      2. __init__(self: pyigl.AABB, arg0: pyigl.AABB) -> None
     |
     |  init(...)
     |      init(self: pyigl.AABB, arg0: pyigl.eigen.MatrixXd, arg1: pyigl.eigen.MatrixXi) -> None
     |
     |  squared_distance(...)
     |      squared_distance(self: pyigl.AABB, arg0: pyigl.eigen.MatrixXd, arg1: pyigl.eigen.MatrixXi, arg2: pyigl.eigen.MatrixXd, arg3: pyigl.eigen.MatrixXd, arg4: pyigl.eigen.MatrixXi, arg5: pyigl.eigen.MatrixXd) -> None
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class ARAPData(pybind11_builtins.pybind11_object)
     |  Method resolution order:
     |      ARAPData
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(...)
     |      __init__(self: pyigl.ARAPData) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  CSM
     |
     |  G
     |
     |  K
     |
     |  M
     |
     |  b
     |
     |  dim
     |
     |  energy
     |
     |  f_ext
     |
     |  h
     |
     |  max_iter
     |
     |  n
     |
     |  vel
     |
     |  with_dynamics
     |
     |  ym
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class ARAPEnergyType(pybind11_builtins.pybind11_object)
     |  Members:
     |
     |  ARAP_ENERGY_TYPE_SPOKES
     |
     |  ARAP_ENERGY_TYPE_SPOKES_AND_RIMS
     |
     |  ARAP_ENERGY_TYPE_ELEMENTS
     |
     |  ARAP_ENERGY_TYPE_DEFAULT
     |
     |  NUM_ARAP_ENERGY_TYPES
     |
     |  Method resolution order:
     |      ARAPEnergyType
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __eq__(...)
     |      __eq__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __eq__(self: pyigl.ARAPEnergyType, arg0: pyigl.ARAPEnergyType) -> bool
     |
     |      2. __eq__(self: pyigl.ARAPEnergyType, arg0: int) -> bool
     |
     |  __getstate__(...)
     |      __getstate__(self: pyigl.ARAPEnergyType) -> tuple
     |
     |  __hash__(...)
     |      __hash__(self: pyigl.ARAPEnergyType) -> int
     |
     |  __init__(...)
     |      __init__(self: pyigl.ARAPEnergyType, arg0: int) -> None
     |
     |  __int__(...)
     |      __int__(self: pyigl.ARAPEnergyType) -> int
     |
     |  __ne__(...)
     |      __ne__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __ne__(self: pyigl.ARAPEnergyType, arg0: pyigl.ARAPEnergyType) -> bool
     |
     |      2. __ne__(self: pyigl.ARAPEnergyType, arg0: int) -> bool
     |
     |  __repr__(...)
     |      __repr__(self: pyigl.ARAPEnergyType) -> str
     |
     |  __setstate__(...)
     |      __setstate__(self: pyigl.ARAPEnergyType, arg0: tuple) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __members__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  ARAP_ENERGY_TYPE_DEFAULT = ARAPEnergyType.ARAP_ENERGY_TYPE_DEFAULT
     |
     |  ARAP_ENERGY_TYPE_ELEMENTS = ARAPEnergyType.ARAP_ENERGY_TYPE_ELEMENTS
     |
     |  ARAP_ENERGY_TYPE_SPOKES = ARAPEnergyType.ARAP_ENERGY_TYPE_SPOKES
     |
     |  ARAP_ENERGY_TYPE_SPOKES_AND_RIMS = ARAPEnergyType.ARAP_ENERGY_TYPE_SPO...
     |
     |  NUM_ARAP_ENERGY_TYPES = ARAPEnergyType.NUM_ARAP_ENERGY_TYPES
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class BBWData(pybind11_builtins.pybind11_object)
     |  Method resolution order:
     |      BBWData
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(...)
     |      __init__(self: pyigl.BBWData) -> None
     |
     |  print(...)
     |      print(self: pyigl.BBWData) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  W0
     |
     |  active_set_params
     |
     |  partition_unity
     |
     |  verbosity
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class EigsType(pybind11_builtins.pybind11_object)
     |  Members:
     |
     |  EIGS_TYPE_SM
     |
     |  EIGS_TYPE_LM
     |
     |  NUM_EIGS_TYPES
     |
     |  Method resolution order:
     |      EigsType
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __eq__(...)
     |      __eq__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __eq__(self: pyigl.EigsType, arg0: pyigl.EigsType) -> bool
     |
     |      2. __eq__(self: pyigl.EigsType, arg0: int) -> bool
     |
     |  __getstate__(...)
     |      __getstate__(self: pyigl.EigsType) -> tuple
     |
     |  __hash__(...)
     |      __hash__(self: pyigl.EigsType) -> int
     |
     |  __init__(...)
     |      __init__(self: pyigl.EigsType, arg0: int) -> None
     |
     |  __int__(...)
     |      __int__(self: pyigl.EigsType) -> int
     |
     |  __ne__(...)
     |      __ne__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __ne__(self: pyigl.EigsType, arg0: pyigl.EigsType) -> bool
     |
     |      2. __ne__(self: pyigl.EigsType, arg0: int) -> bool
     |
     |  __repr__(...)
     |      __repr__(self: pyigl.EigsType) -> str
     |
     |  __setstate__(...)
     |      __setstate__(self: pyigl.EigsType, arg0: tuple) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __members__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  EIGS_TYPE_LM = EigsType.EIGS_TYPE_LM
     |
     |  EIGS_TYPE_SM = EigsType.EIGS_TYPE_SM
     |
     |  NUM_EIGS_TYPES = EigsType.NUM_EIGS_TYPES
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class MassMatrixType(pybind11_builtins.pybind11_object)
     |  Members:
     |
     |  MASSMATRIX_TYPE_BARYCENTRIC
     |
     |  MASSMATRIX_TYPE_VORONOI
     |
     |  MASSMATRIX_TYPE_FULL
     |
     |  MASSMATRIX_TYPE_DEFAULT
     |
     |  NUM_MASSMATRIX_TYPE
     |
     |  Method resolution order:
     |      MassMatrixType
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __eq__(...)
     |      __eq__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __eq__(self: pyigl.MassMatrixType, arg0: pyigl.MassMatrixType) -> bool
     |
     |      2. __eq__(self: pyigl.MassMatrixType, arg0: int) -> bool
     |
     |  __getstate__(...)
     |      __getstate__(self: pyigl.MassMatrixType) -> tuple
     |
     |  __hash__(...)
     |      __hash__(self: pyigl.MassMatrixType) -> int
     |
     |  __init__(...)
     |      __init__(self: pyigl.MassMatrixType, arg0: int) -> None
     |
     |  __int__(...)
     |      __int__(self: pyigl.MassMatrixType) -> int
     |
     |  __ne__(...)
     |      __ne__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __ne__(self: pyigl.MassMatrixType, arg0: pyigl.MassMatrixType) -> bool
     |
     |      2. __ne__(self: pyigl.MassMatrixType, arg0: int) -> bool
     |
     |  __repr__(...)
     |      __repr__(self: pyigl.MassMatrixType) -> str
     |
     |  __setstate__(...)
     |      __setstate__(self: pyigl.MassMatrixType, arg0: tuple) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __members__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  MASSMATRIX_TYPE_BARYCENTRIC = MassMatrixType.MASSMATRIX_TYPE_BARYCENTR...
     |
     |  MASSMATRIX_TYPE_DEFAULT = MassMatrixType.MASSMATRIX_TYPE_DEFAULT
     |
     |  MASSMATRIX_TYPE_FULL = MassMatrixType.MASSMATRIX_TYPE_FULL
     |
     |  MASSMATRIX_TYPE_VORONOI = MassMatrixType.MASSMATRIX_TYPE_VORONOI
     |
     |  NUM_MASSMATRIX_TYPE = MassMatrixType.NUM_MASSMATRIX_TYPE
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class MeshBooleanType(pybind11_builtins.pybind11_object)
     |  Members:
     |
     |  MESH_BOOLEAN_TYPE_UNION
     |
     |  MESH_BOOLEAN_TYPE_INTERSECT
     |
     |  MESH_BOOLEAN_TYPE_MINUS
     |
     |  MESH_BOOLEAN_TYPE_XOR
     |
     |  MESH_BOOLEAN_TYPE_RESOLVE
     |
     |  NUM_MESH_BOOLEAN_TYPES
     |
     |  Method resolution order:
     |      MeshBooleanType
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __eq__(...)
     |      __eq__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __eq__(self: pyigl.MeshBooleanType, arg0: pyigl.MeshBooleanType) -> bool
     |
     |      2. __eq__(self: pyigl.MeshBooleanType, arg0: int) -> bool
     |
     |  __getstate__(...)
     |      __getstate__(self: pyigl.MeshBooleanType) -> tuple
     |
     |  __hash__(...)
     |      __hash__(self: pyigl.MeshBooleanType) -> int
     |
     |  __init__(...)
     |      __init__(self: pyigl.MeshBooleanType, arg0: int) -> None
     |
     |  __int__(...)
     |      __int__(self: pyigl.MeshBooleanType) -> int
     |
     |  __ne__(...)
     |      __ne__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __ne__(self: pyigl.MeshBooleanType, arg0: pyigl.MeshBooleanType) -> bool
     |
     |      2. __ne__(self: pyigl.MeshBooleanType, arg0: int) -> bool
     |
     |  __repr__(...)
     |      __repr__(self: pyigl.MeshBooleanType) -> str
     |
     |  __setstate__(...)
     |      __setstate__(self: pyigl.MeshBooleanType, arg0: tuple) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __members__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  MESH_BOOLEAN_TYPE_INTERSECT = MeshBooleanType.MESH_BOOLEAN_TYPE_INTERS...
     |
     |  MESH_BOOLEAN_TYPE_MINUS = MeshBooleanType.MESH_BOOLEAN_TYPE_MINUS
     |
     |  MESH_BOOLEAN_TYPE_RESOLVE = MeshBooleanType.MESH_BOOLEAN_TYPE_RESOLVE
     |
     |  MESH_BOOLEAN_TYPE_UNION = MeshBooleanType.MESH_BOOLEAN_TYPE_UNION
     |
     |  MESH_BOOLEAN_TYPE_XOR = MeshBooleanType.MESH_BOOLEAN_TYPE_XOR
     |
     |  NUM_MESH_BOOLEAN_TYPES = MeshBooleanType.NUM_MESH_BOOLEAN_TYPES
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class PerEdgeNormalsWeightingType(pybind11_builtins.pybind11_object)
     |  Members:
     |
     |  PER_EDGE_NORMALS_WEIGHTING_TYPE_UNIFORM
     |
     |  PER_EDGE_NORMALS_WEIGHTING_TYPE_AREA
     |
     |  PER_EDGE_NORMALS_WEIGHTING_TYPE_DEFAULT
     |
     |  NUM_PER_EDGE_NORMALS_WEIGHTING_TYPE
     |
     |  Method resolution order:
     |      PerEdgeNormalsWeightingType
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __eq__(...)
     |      __eq__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __eq__(self: pyigl.PerEdgeNormalsWeightingType, arg0: pyigl.PerEdgeNormalsWeightingType) -> bool
     |
     |      2. __eq__(self: pyigl.PerEdgeNormalsWeightingType, arg0: int) -> bool
     |
     |  __getstate__(...)
     |      __getstate__(self: pyigl.PerEdgeNormalsWeightingType) -> tuple
     |
     |  __hash__(...)
     |      __hash__(self: pyigl.PerEdgeNormalsWeightingType) -> int
     |
     |  __init__(...)
     |      __init__(self: pyigl.PerEdgeNormalsWeightingType, arg0: int) -> None
     |
     |  __int__(...)
     |      __int__(self: pyigl.PerEdgeNormalsWeightingType) -> int
     |
     |  __ne__(...)
     |      __ne__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __ne__(self: pyigl.PerEdgeNormalsWeightingType, arg0: pyigl.PerEdgeNormalsWeightingType) -> bool
     |
     |      2. __ne__(self: pyigl.PerEdgeNormalsWeightingType, arg0: int) -> bool
     |
     |  __repr__(...)
     |      __repr__(self: pyigl.PerEdgeNormalsWeightingType) -> str
     |
     |  __setstate__(...)
     |      __setstate__(self: pyigl.PerEdgeNormalsWeightingType, arg0: tuple) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __members__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  NUM_PER_EDGE_NORMALS_WEIGHTING_TYPE = PerEdgeNormalsWeightingType.NUM_...
     |
     |  PER_EDGE_NORMALS_WEIGHTING_TYPE_AREA = PerEdgeNormalsWeightingType.PER...
     |
     |  PER_EDGE_NORMALS_WEIGHTING_TYPE_DEFAULT = PerEdgeNormalsWeightingType....
     |
     |  PER_EDGE_NORMALS_WEIGHTING_TYPE_UNIFORM = PerEdgeNormalsWeightingType....
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class PerVertexNormalsWeightingType(pybind11_builtins.pybind11_object)
     |  Members:
     |
     |  PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM
     |
     |  PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA
     |
     |  PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE
     |
     |  PER_VERTEX_NORMALS_WEIGHTING_TYPE_DEFAULT
     |
     |  NUM_PER_VERTEX_NORMALS_WEIGHTING_TYPE
     |
     |  Method resolution order:
     |      PerVertexNormalsWeightingType
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __eq__(...)
     |      __eq__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __eq__(self: pyigl.PerVertexNormalsWeightingType, arg0: pyigl.PerVertexNormalsWeightingType) -> bool
     |
     |      2. __eq__(self: pyigl.PerVertexNormalsWeightingType, arg0: int) -> bool
     |
     |  __getstate__(...)
     |      __getstate__(self: pyigl.PerVertexNormalsWeightingType) -> tuple
     |
     |  __hash__(...)
     |      __hash__(self: pyigl.PerVertexNormalsWeightingType) -> int
     |
     |  __init__(...)
     |      __init__(self: pyigl.PerVertexNormalsWeightingType, arg0: int) -> None
     |
     |  __int__(...)
     |      __int__(self: pyigl.PerVertexNormalsWeightingType) -> int
     |
     |  __ne__(...)
     |      __ne__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __ne__(self: pyigl.PerVertexNormalsWeightingType, arg0: pyigl.PerVertexNormalsWeightingType) -> bool
     |
     |      2. __ne__(self: pyigl.PerVertexNormalsWeightingType, arg0: int) -> bool
     |
     |  __repr__(...)
     |      __repr__(self: pyigl.PerVertexNormalsWeightingType) -> str
     |
     |  __setstate__(...)
     |      __setstate__(self: pyigl.PerVertexNormalsWeightingType, arg0: tuple) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __members__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  NUM_PER_VERTEX_NORMALS_WEIGHTING_TYPE = PerVertexNormalsWeightingType....
     |
     |  PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE = PerVertexNormalsWeightingTyp...
     |
     |  PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA = PerVertexNormalsWeightingType...
     |
     |  PER_VERTEX_NORMALS_WEIGHTING_TYPE_DEFAULT = PerVertexNormalsWeightingT...
     |
     |  PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM = PerVertexNormalsWeightingT...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class RotationList(pybind11_builtins.pybind11_object)
     |  Method resolution order:
     |      RotationList
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __getitem__(...)
     |      __getitem__(self: pyigl.RotationList, arg0: int) -> pyigl.eigen.Quaterniond
     |
     |  __init__(...)
     |      __init__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __init__(self: pyigl.RotationList) -> None
     |
     |      2. __init__(self: pyigl.RotationList, arg0: int) -> None
     |
     |  __iter__(...)
     |      __iter__(self: pyigl.RotationList) -> iterator
     |
     |  __len__(...)
     |      __len__(self: pyigl.RotationList) -> int
     |
     |  __setitem__(...)
     |      __setitem__(self: pyigl.RotationList, arg0: int, arg1: pyigl.eigen.Quaterniond) -> pyigl.eigen.Quaterniond
     |
     |  append(...)
     |      append(self: pyigl.RotationList, arg0: pyigl.eigen.Quaterniond) -> None
     |
     |  back(...)
     |      back(self: pyigl.RotationList) -> pyigl.eigen.Quaterniond
     |
     |  pop_back(...)
     |      pop_back(self: pyigl.RotationList) -> None
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class SignedDistanceType(pybind11_builtins.pybind11_object)
     |  Members:
     |
     |  SIGNED_DISTANCE_TYPE_PSEUDONORMAL
     |
     |  SIGNED_DISTANCE_TYPE_WINDING_NUMBER
     |
     |  SIGNED_DISTANCE_TYPE_DEFAULT
     |
     |  SIGNED_DISTANCE_TYPE_UNSIGNED
     |
     |  NUM_SIGNED_DISTANCE_TYPE
     |
     |  Method resolution order:
     |      SignedDistanceType
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __eq__(...)
     |      __eq__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __eq__(self: pyigl.SignedDistanceType, arg0: pyigl.SignedDistanceType) -> bool
     |
     |      2. __eq__(self: pyigl.SignedDistanceType, arg0: int) -> bool
     |
     |  __getstate__(...)
     |      __getstate__(self: pyigl.SignedDistanceType) -> tuple
     |
     |  __hash__(...)
     |      __hash__(self: pyigl.SignedDistanceType) -> int
     |
     |  __init__(...)
     |      __init__(self: pyigl.SignedDistanceType, arg0: int) -> None
     |
     |  __int__(...)
     |      __int__(self: pyigl.SignedDistanceType) -> int
     |
     |  __ne__(...)
     |      __ne__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __ne__(self: pyigl.SignedDistanceType, arg0: pyigl.SignedDistanceType) -> bool
     |
     |      2. __ne__(self: pyigl.SignedDistanceType, arg0: int) -> bool
     |
     |  __repr__(...)
     |      __repr__(self: pyigl.SignedDistanceType) -> str
     |
     |  __setstate__(...)
     |      __setstate__(self: pyigl.SignedDistanceType, arg0: tuple) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __members__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  NUM_SIGNED_DISTANCE_TYPE = SignedDistanceType.NUM_SIGNED_DISTANCE_TYPE
     |
     |  SIGNED_DISTANCE_TYPE_DEFAULT = SignedDistanceType.SIGNED_DISTANCE_TYPE...
     |
     |  SIGNED_DISTANCE_TYPE_PSEUDONORMAL = SignedDistanceType.SIGNED_DISTANCE...
     |
     |  SIGNED_DISTANCE_TYPE_UNSIGNED = SignedDistanceType.SIGNED_DISTANCE_TYP...
     |
     |  SIGNED_DISTANCE_TYPE_WINDING_NUMBER = SignedDistanceType.SIGNED_DISTAN...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class SolverStatus(pybind11_builtins.pybind11_object)
     |  Members:
     |
     |  SOLVER_STATUS_CONVERGED
     |
     |  SOLVER_STATUS_MAX_ITER
     |
     |  SOLVER_STATUS_ERROR
     |
     |  NUM_SOLVER_STATUSES
     |
     |  Method resolution order:
     |      SolverStatus
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __eq__(...)
     |      __eq__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __eq__(self: pyigl.SolverStatus, arg0: pyigl.SolverStatus) -> bool
     |
     |      2. __eq__(self: pyigl.SolverStatus, arg0: int) -> bool
     |
     |  __getstate__(...)
     |      __getstate__(self: pyigl.SolverStatus) -> tuple
     |
     |  __hash__(...)
     |      __hash__(self: pyigl.SolverStatus) -> int
     |
     |  __init__(...)
     |      __init__(self: pyigl.SolverStatus, arg0: int) -> None
     |
     |  __int__(...)
     |      __int__(self: pyigl.SolverStatus) -> int
     |
     |  __ne__(...)
     |      __ne__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __ne__(self: pyigl.SolverStatus, arg0: pyigl.SolverStatus) -> bool
     |
     |      2. __ne__(self: pyigl.SolverStatus, arg0: int) -> bool
     |
     |  __repr__(...)
     |      __repr__(self: pyigl.SolverStatus) -> str
     |
     |  __setstate__(...)
     |      __setstate__(self: pyigl.SolverStatus, arg0: tuple) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __members__
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  NUM_SOLVER_STATUSES = SolverStatus.NUM_SOLVER_STATUSES
     |
     |  SOLVER_STATUS_CONVERGED = SolverStatus.SOLVER_STATUS_CONVERGED
     |
     |  SOLVER_STATUS_ERROR = SolverStatus.SOLVER_STATUS_ERROR
     |
     |  SOLVER_STATUS_MAX_ITER = SolverStatus.SOLVER_STATUS_MAX_ITER
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class VectorInt(pybind11_builtins.pybind11_object)
     |  Method resolution order:
     |      VectorInt
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __bool__(...)
     |      __bool__(self: pyigl.VectorInt) -> bool
     |
     |      Check whether the list is nonempty
     |
     |  __contains__(...)
     |      __contains__(self: pyigl.VectorInt, x: int) -> bool
     |
     |      Return true the container contains ``x``
     |
     |  __delitem__(...)
     |      __delitem__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __delitem__(self: pyigl.VectorInt, arg0: int) -> None
     |
     |      Delete the list elements at index ``i``
     |
     |      2. __delitem__(self: pyigl.VectorInt, arg0: slice) -> None
     |
     |      Delete list elements using a slice object
     |
     |  __eq__(...)
     |      __eq__(self: pyigl.VectorInt, arg0: pyigl.VectorInt) -> bool
     |
     |  __getitem__(...)
     |      __getitem__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __getitem__(self: pyigl.VectorInt, s: slice) -> pyigl.VectorInt
     |
     |      Retrieve list elements using a slice object
     |
     |      2. __getitem__(self: pyigl.VectorInt, arg0: int) -> int
     |
     |  __init__(...)
     |      __init__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __init__(self: pyigl.VectorInt) -> None
     |
     |      2. __init__(self: pyigl.VectorInt, arg0: pyigl.VectorInt) -> None
     |
     |      Copy constructor
     |
     |      3. __init__(self: pyigl.VectorInt, arg0: iterable) -> None
     |
     |  __iter__(...)
     |      __iter__(self: pyigl.VectorInt) -> iterator
     |
     |  __len__(...)
     |      __len__(self: pyigl.VectorInt) -> int
     |
     |  __ne__(...)
     |      __ne__(self: pyigl.VectorInt, arg0: pyigl.VectorInt) -> bool
     |
     |  __repr__(...)
     |      __repr__(self: pyigl.VectorInt) -> str
     |
     |      Return the canonical string representation of this list.
     |
     |  __setitem__(...)
     |      __setitem__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __setitem__(self: pyigl.VectorInt, arg0: int, arg1: int) -> None
     |
     |      2. __setitem__(self: pyigl.VectorInt, arg0: slice, arg1: pyigl.VectorInt) -> None
     |
     |      Assign list elements using a slice object
     |
     |  append(...)
     |      append(self: pyigl.VectorInt, x: int) -> None
     |
     |      Add an item to the end of the list
     |
     |  count(...)
     |      count(self: pyigl.VectorInt, x: int) -> int
     |
     |      Return the number of times ``x`` appears in the list
     |
     |  extend(...)
     |      extend(self: pyigl.VectorInt, L: pyigl.VectorInt) -> None
     |
     |      Extend the list by appending all the items in the given list
     |
     |  insert(...)
     |      insert(self: pyigl.VectorInt, i: int, x: int) -> None
     |
     |      Insert an item at a given position.
     |
     |  pop(...)
     |      pop(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. pop(self: pyigl.VectorInt) -> int
     |
     |      Remove and return the last item
     |
     |      2. pop(self: pyigl.VectorInt, i: int) -> int
     |
     |      Remove and return the item at index ``i``
     |
     |  remove(...)
     |      remove(self: pyigl.VectorInt, x: int) -> None
     |
     |      Remove the first item from the list whose value is x. It is an error if there is no such item.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __pybind11_module_local_v1__ = <capsule object NULL>
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class VectorVectorInt(pybind11_builtins.pybind11_object)
     |  Method resolution order:
     |      VectorVectorInt
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __bool__(...)
     |      __bool__(self: pyigl.VectorVectorInt) -> bool
     |
     |      Check whether the list is nonempty
     |
     |  __contains__(...)
     |      __contains__(self: pyigl.VectorVectorInt, x: pyigl.VectorInt) -> bool
     |
     |      Return true the container contains ``x``
     |
     |  __delitem__(...)
     |      __delitem__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __delitem__(self: pyigl.VectorVectorInt, arg0: int) -> None
     |
     |      Delete the list elements at index ``i``
     |
     |      2. __delitem__(self: pyigl.VectorVectorInt, arg0: slice) -> None
     |
     |      Delete list elements using a slice object
     |
     |  __eq__(...)
     |      __eq__(self: pyigl.VectorVectorInt, arg0: pyigl.VectorVectorInt) -> bool
     |
     |  __getitem__(...)
     |      __getitem__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __getitem__(self: pyigl.VectorVectorInt, s: slice) -> pyigl.VectorVectorInt
     |
     |      Retrieve list elements using a slice object
     |
     |      2. __getitem__(self: pyigl.VectorVectorInt, arg0: int) -> pyigl.VectorInt
     |
     |  __init__(...)
     |      __init__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __init__(self: pyigl.VectorVectorInt) -> None
     |
     |      2. __init__(self: pyigl.VectorVectorInt, arg0: pyigl.VectorVectorInt) -> None
     |
     |      Copy constructor
     |
     |      3. __init__(self: pyigl.VectorVectorInt, arg0: iterable) -> None
     |
     |  __iter__(...)
     |      __iter__(self: pyigl.VectorVectorInt) -> iterator
     |
     |  __len__(...)
     |      __len__(self: pyigl.VectorVectorInt) -> int
     |
     |  __ne__(...)
     |      __ne__(self: pyigl.VectorVectorInt, arg0: pyigl.VectorVectorInt) -> bool
     |
     |  __setitem__(...)
     |      __setitem__(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. __setitem__(self: pyigl.VectorVectorInt, arg0: int, arg1: pyigl.VectorInt) -> None
     |
     |      2. __setitem__(self: pyigl.VectorVectorInt, arg0: slice, arg1: pyigl.VectorVectorInt) -> None
     |
     |      Assign list elements using a slice object
     |
     |  append(...)
     |      append(self: pyigl.VectorVectorInt, x: pyigl.VectorInt) -> None
     |
     |      Add an item to the end of the list
     |
     |  count(...)
     |      count(self: pyigl.VectorVectorInt, x: pyigl.VectorInt) -> int
     |
     |      Return the number of times ``x`` appears in the list
     |
     |  extend(...)
     |      extend(self: pyigl.VectorVectorInt, L: pyigl.VectorVectorInt) -> None
     |
     |      Extend the list by appending all the items in the given list
     |
     |  insert(...)
     |      insert(self: pyigl.VectorVectorInt, i: int, x: pyigl.VectorInt) -> None
     |
     |      Insert an item at a given position.
     |
     |  pop(...)
     |      pop(*args, **kwargs)
     |      Overloaded function.
     |
     |      1. pop(self: pyigl.VectorVectorInt) -> pyigl.VectorInt
     |
     |      Remove and return the last item
     |
     |      2. pop(self: pyigl.VectorVectorInt, i: int) -> pyigl.VectorInt
     |
     |      Remove and return the item at index ``i``
     |
     |  remove(...)
     |      remove(self: pyigl.VectorVectorInt, x: pyigl.VectorInt) -> None
     |
     |      Remove the first item from the list whose value is x. It is an error if there is no such item.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __pybind11_module_local_v1__ = <capsule object NULL>
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class active_set_params(pybind11_builtins.pybind11_object)
     |  Method resolution order:
     |      active_set_params
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(...)
     |      __init__(self: pyigl.active_set_params) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  Auu_pd
     |
     |  constraint_threshold
     |
     |  inactive_threshold
     |
     |  max_iter
     |
     |  solution_diff_threshold
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

    class min_quad_with_fixed_data(pybind11_builtins.pybind11_object)
     |  Method resolution order:
     |      min_quad_with_fixed_data
     |      pybind11_builtins.pybind11_object
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(...)
     |      __init__(self: pyigl.min_quad_with_fixed_data) -> None
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pybind11_builtins.pybind11_object:
     |
     |  __new__(*args, **kwargs) from pybind11_builtins.pybind11_type
     |      Create and return a new object.  See help(type) for accurate signature.

FUNCTIONS
    active_set(...) method of builtins.PyCapsule instance
        active_set(A: pyigl.eigen.SparseMatrixd, B: pyigl.eigen.MatrixXd, known: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXd, Aeq: pyigl.eigen.SparseMatrixd, Beq: pyigl.eigen.MatrixXd, Aieq: pyigl.eigen.SparseMatrixd, Bieq: pyigl.eigen.MatrixXd, lx: pyigl.eigen.MatrixXd, ux: pyigl.eigen.MatrixXd, params: pyigl.active_set_params, Z: pyigl.eigen.MatrixXd) -> pyigl.SolverStatus

        // Known Bugs: rows of [Aeq;Aieq] **must** be linearly independent. Should be
          // using QR decomposition otherwise:
          //   http://www.okstate.edu/sas/v8/sashtml/ormp/chap5/sect32.htm
          //
          // ACTIVE_SET Minimize quadratic energy
          //
          // 0.5*Z'*A*Z + Z'*B + C with constraints
          //
          // that Z(known) = Y, optionally also subject to the constraints Aeq*Z = Beq,
          // and further optionally subject to the linear inequality constraints that
          // Aieq*Z <= Bieq and constant inequality constraints lx <= x <= ux
          //
          // Inputs:
          //   A  n by n matrix of quadratic coefficients
          //   B  n by 1 column of linear coefficients
          //   known  list of indices to known rows in Z
          //   Y  list of fixed values corresponding to known rows in Z
          //   Aeq  meq by n list of linear equality constraint coefficients
          //   Beq  meq by 1 list of linear equality constraint constant values
          //   Aieq  mieq by n list of linear inequality constraint coefficients
          //   Bieq  mieq by 1 list of linear inequality constraint constant values
          //   lx  n by 1 list of lower bounds [] implies -Inf
          //   ux  n by 1 list of upper bounds [] implies Inf
          //   params  struct of additional parameters (see below)
          //   Z  if not empty, is taken to be an n by 1 list of initial guess values
          //     (see output)
          // Outputs:
          //   Z  n by 1 list of solution values
          // Returns true on success, false on error
          //
          // Benchmark: For a harmonic solve on a mesh with 325K facets, matlab 2.2
          // secs, igl/min_quad_with_fixed.h 7.1 secs
          //

    adjacency_list(...) method of builtins.PyCapsule instance
        adjacency_list(F: pyigl.eigen.MatrixXi, A: pyigl.VectorVectorInt, sorted: bool = False) -> None

    adjacency_matrix(...) method of builtins.PyCapsule instance
        adjacency_matrix(F: pyigl.eigen.MatrixXi, A: pyigl.eigen.SparseMatrixi) -> None

    arap_precomputation(...) method of builtins.PyCapsule instance
        arap_precomputation(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, dim: int, b: pyigl.eigen.MatrixXi, data: pyigl.ARAPData) -> bool

        // Compute necessary information to start using an ARAP deformation
          //
          // Inputs:
          //   V  #V by dim list of mesh positions
          //   F  #F by simplex-size list of triangle|tet indices into V
          //   dim  dimension being used at solve time. For deformation usually dim =
          //     V.cols(), for surface parameterization V.cols() = 3 and dim = 2
          //   b  #b list of "boundary" fixed vertex indices into V
          // Outputs:
          //   data  struct containing necessary precomputation

    arap_solve(...) method of builtins.PyCapsule instance
        arap_solve(bc: pyigl.eigen.MatrixXd, data: pyigl.ARAPData, U: pyigl.eigen.MatrixXd) -> bool

        // Inputs:
          //   bc  #b by dim list of boundary conditions
          //   data  struct containing necessary precomputation and parameters
          //   U  #V by dim initial guess

    avg_edge_length(...) method of builtins.PyCapsule instance
        avg_edge_length(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi) -> float

        // Compute the average edge length for the given triangle mesh
          // Templates:
          //   DerivedV derived from vertex positions matrix type: i.e. MatrixXd
          //   DerivedF derived from face indices matrix type: i.e. MatrixXi
          //   DerivedL derived from edge lengths matrix type: i.e. MatrixXd
          // Inputs:
          //   V  eigen matrix #V by 3
          //   F  #F by simplex-size list of mesh faces (must be simplex)
          // Outputs:
          //   l  average edge length
          //
          // See also: adjacency_matrix

    barycenter(...) method of builtins.PyCapsule instance
        barycenter(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, BC: pyigl.eigen.MatrixXd) -> None

        // Computes the barycenter of every simplex
          //
          // Inputs:
          //   V  #V x dim matrix of vertex coordinates
          //   F  #F x simplex_size  matrix of indices of simplex corners into V
          // Output:
          //   BC  #F x dim matrix of 3d vertices
          //

    barycentric_coordinates(...) method of builtins.PyCapsule instance
        barycentric_coordinates(*args, **kwargs)
        Overloaded function.

        1. barycentric_coordinates(P: pyigl.eigen.MatrixXd, A: pyigl.eigen.MatrixXd, B: pyigl.eigen.MatrixXd, C: pyigl.eigen.MatrixXd, D: pyigl.eigen.MatrixXd, L: pyigl.eigen.MatrixXd) -> None

        // Compute barycentric coordinates in a tet
          //
          // Inputs:
          //   P  #P by 3 Query points in 3d
          //   A  #P by 3 Tet corners in 3d
          //   B  #P by 3 Tet corners in 3d
          //   C  #P by 3 Tet corners in 3d
          //   D  #P by 3 Tet corners in 3d
          // Outputs:
          //   L  #P by 4 list of barycentric coordinates
          //

        2. barycentric_coordinates(P: pyigl.eigen.MatrixXd, A: pyigl.eigen.MatrixXd, B: pyigl.eigen.MatrixXd, C: pyigl.eigen.MatrixXd, L: pyigl.eigen.MatrixXd) -> None

        // Compute barycentric coordinates in a tet
          //
          // Inputs:
          //   P  #P by 3 Query points in 3d
          //   A  #P by 3 Tet corners in 3d
          //   B  #P by 3 Tet corners in 3d
          //   C  #P by 3 Tet corners in 3d
          //   D  #P by 3 Tet corners in 3d
          // Outputs:
          //   L  #P by 4 list of barycentric coordinates
          //

    barycentric_to_global(...) method of builtins.PyCapsule instance
        barycentric_to_global(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, bc: pyigl.eigen.MatrixXd) -> pyigl.eigen.MatrixXd

        // Converts barycentric coordinates in the embree form to 3D coordinates
          // Embree stores barycentric coordinates as triples: fid, bc1, bc2
          // fid is the id of a face, bc1 is the displacement of the point wrt the
          // first vertex v0 and the edge v1-v0. Similarly, bc2 is the displacement
          // wrt v2-v0.
          //
          // Input:
          // V:  #Vx3 Vertices of the mesh
          // F:  #Fxe Faces of the mesh
          // bc: #Xx3 Barycentric coordinates, one row per point
          //
          // Output:
          // #X: #Xx3 3D coordinates of all points in bc

    bbw(...) method of builtins.PyCapsule instance
        bbw(V: pyigl.eigen.MatrixXd, Ele: pyigl.eigen.MatrixXi, b: pyigl.eigen.MatrixXi, bc: pyigl.eigen.MatrixXd, data: pyigl.BBWData, W: pyigl.eigen.MatrixXd) -> bool

        // Compute Bounded Biharmonic Weights on a given domain (V,Ele) with a given
          // set of boundary conditions
          //
          // Templates
          //   DerivedV  derived type of eigen matrix for V (e.g. MatrixXd)
          //   DerivedF  derived type of eigen matrix for F (e.g. MatrixXi)
          //   Derivedb  derived type of eigen matrix for b (e.g. VectorXi)
          //   Derivedbc  derived type of eigen matrix for bc (e.g. MatrixXd)
          //   DerivedW  derived type of eigen matrix for W (e.g. MatrixXd)
          // Inputs:
          //   V  #V by dim vertex positions
          //   Ele  #Elements by simplex-size list of element indices
          //   b  #b boundary indices into V
          //   bc #b by #W list of boundary values
          //   data  object containing options, initial guess --> solution and results
          // Outputs:
          //   W  #V by #W list of *unnormalized* weights to normalize use
          //    igl::normalize_row_sums(W,W);
          // Returns true on success, false on failure

    boundary_conditions(...) method of builtins.PyCapsule instance
        boundary_conditions(V: pyigl.eigen.MatrixXd, Ele: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXd, P: pyigl.eigen.MatrixXi, BE: pyigl.eigen.MatrixXi, CE: pyigl.eigen.MatrixXi, b: pyigl.eigen.MatrixXi, bc: pyigl.eigen.MatrixXd) -> None

        // Compute boundary conditions for automatic weights computation. This
          // function expects that the given mesh (V,Ele) has sufficient samples
          // (vertices) exactly at point handle locations and exactly along bone and
          // cage edges.
          //
          // Inputs:
          //   V  #V by dim list of domain vertices
          //   Ele  #Ele by simplex-size list of simplex indices
          //   C  #C by dim list of handle positions
          //   P  #P by 1 list of point handle indices into C
          //   BE  #BE by 2 list of bone edge indices into C
          //   CE  #CE by 2 list of cage edge indices into *P*
          // Outputs:
          //   b  #b list of boundary indices (indices into V of vertices which have
          //     known, fixed values)
          //   bc #b by #weights list of known/fixed values for boundary vertices
          //     (notice the #b != #weights in general because #b will include all the
          //     intermediary samples along each bone, etc.. The ordering of the
          //     weights corresponds to [P;BE]
          // Returns false if boundary conditions are suspicious:
          //   P and BE are empty
          //   bc is empty
          //   some column of bc doesn't have a 0 (assuming bc has >1 columns)
          //   some column of bc doesn't have a 1 (assuming bc has >1 columns)

    boundary_facets(...) method of builtins.PyCapsule instance
        boundary_facets(*args, **kwargs)
        Overloaded function.

        1. boundary_facets(T: pyigl.eigen.MatrixXi, F: pyigl.eigen.MatrixXi) -> None

        // BOUNDARY_FACETS Determine boundary faces (edges) of tetrahedra (triangles)
          // stored in T (analogous to qptoolbox's `outline` and `boundary_faces`).
          //
          // Templates:
          //   IntegerT  integer-value: e.g. int
          //   IntegerF  integer-value: e.g. int
          // Input:
          //  T  tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra
          // Output:
          //  F  list of boundary faces, n by 3 (2), where n is the number of boundary faces
          //
          //

        2. boundary_facets(T: pyigl.eigen.MatrixXi) -> pyigl.eigen.MatrixXi

        // BOUNDARY_FACETS Determine boundary faces (edges) of tetrahedra (triangles)
          // stored in T (analogous to qptoolbox's `outline` and `boundary_faces`).
          //
          // Templates:
          //   IntegerT  integer-value: e.g. int
          //   IntegerF  integer-value: e.g. int
          // Input:
          //  T  tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra
          // Output:
          //  F  list of boundary faces, n by 3 (2), where n is the number of boundary faces
          //
          //

        3. boundary_facets(T: pyigl.VectorVectorInt, F: pyigl.VectorVectorInt) -> None

        // BOUNDARY_FACETS Determine boundary faces (edges) of tetrahedra (triangles)
          // stored in T (analogous to qptoolbox's `outline` and `boundary_faces`).
          //
          // Templates:
          //   IntegerT  integer-value: e.g. int
          //   IntegerF  integer-value: e.g. int
          // Input:
          //  T  tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra
          // Output:
          //  F  list of boundary faces, n by 3 (2), where n is the number of boundary faces
          //
          //

    boundary_loop(...) method of builtins.PyCapsule instance
        boundary_loop(*args, **kwargs)
        Overloaded function.

        1. boundary_loop(F: pyigl.eigen.MatrixXi, L: pyigl.eigen.MatrixXi) -> None

        // Compute list of ordered boundary loops for a manifold mesh.
          //
          // Templates:
          //  Index  index type
          // Inputs:
          //   F  #V by dim list of mesh faces
          // Outputs:
          //   L  list of loops where L[i] = ordered list of boundary vertices in loop i
          //

        2. boundary_loop(F: pyigl.eigen.MatrixXi, L: pyigl.VectorVectorInt) -> None

        // Compute list of ordered boundary loops for a manifold mesh.
          //
          // Templates:
          //  Index  index type
          // Inputs:
          //   F  #V by dim list of mesh faces
          // Outputs:
          //   L  list of loops where L[i] = ordered list of boundary vertices in loop i
          //

        3. boundary_loop(F: pyigl.eigen.MatrixXi, L: pyigl.VectorInt) -> None

        // Compute list of ordered boundary loops for a manifold mesh.
          //
          // Templates:
          //  Index  index type
          // Inputs:
          //   F  #V by dim list of mesh faces
          // Outputs:
          //   L  list of loops where L[i] = ordered list of boundary vertices in loop i
          //

    cat(...) method of builtins.PyCapsule instance
        cat(*args, **kwargs)
        Overloaded function.

        1. cat(dim: int, A: pyigl.eigen.MatrixXd, B: pyigl.eigen.MatrixXd, C: pyigl.eigen.MatrixXd) -> None

        // Perform concatenation of a two matrices along a single dimension
          // If dim == 1, then C = [A;B]. If dim == 2 then C = [A B]
          //
          // Template:
          //   Scalar  scalar data type for sparse matrices like double or int
          //   Mat  matrix type for all matrices (e.g. MatrixXd, SparseMatrix)
          //   MatC  matrix type for output matrix (e.g. MatrixXd) needs to support
          //     resize
          // Inputs:
          //   A  first input matrix
          //   B  second input matrix
          //   dim  dimension along which to concatenate, 1 or 2
          // Outputs:
          //   C  output matrix
          //

        2. cat(dim: int, A: pyigl.eigen.MatrixXd, B: pyigl.eigen.MatrixXd) -> pyigl.eigen.MatrixXd

        // Perform concatenation of a two matrices along a single dimension
          // If dim == 1, then C = [A;B]. If dim == 2 then C = [A B]
          //
          // Template:
          //   Scalar  scalar data type for sparse matrices like double or int
          //   Mat  matrix type for all matrices (e.g. MatrixXd, SparseMatrix)
          //   MatC  matrix type for output matrix (e.g. MatrixXd) needs to support
          //     resize
          // Inputs:
          //   A  first input matrix
          //   B  second input matrix
          //   dim  dimension along which to concatenate, 1 or 2
          // Outputs:
          //   C  output matrix
          //

        3. cat(dim: int, A: pyigl.eigen.MatrixXi, B: pyigl.eigen.MatrixXi) -> pyigl.eigen.MatrixXi

        // Perform concatenation of a two matrices along a single dimension
          // If dim == 1, then C = [A;B]. If dim == 2 then C = [A B]
          //
          // Template:
          //   Scalar  scalar data type for sparse matrices like double or int
          //   Mat  matrix type for all matrices (e.g. MatrixXd, SparseMatrix)
          //   MatC  matrix type for output matrix (e.g. MatrixXd) needs to support
          //     resize
          // Inputs:
          //   A  first input matrix
          //   B  second input matrix
          //   dim  dimension along which to concatenate, 1 or 2
          // Outputs:
          //   C  output matrix
          //

        4. cat(dim: int, A: pyigl.eigen.SparseMatrixd, B: pyigl.eigen.SparseMatrixd, C: pyigl.eigen.SparseMatrixd) -> None

        // Perform concatenation of a two matrices along a single dimension
          // If dim == 1, then C = [A;B]. If dim == 2 then C = [A B]
          //
          // Template:
          //   Scalar  scalar data type for sparse matrices like double or int
          //   Mat  matrix type for all matrices (e.g. MatrixXd, SparseMatrix)
          //   MatC  matrix type for output matrix (e.g. MatrixXd) needs to support
          //     resize
          // Inputs:
          //   A  first input matrix
          //   B  second input matrix
          //   dim  dimension along which to concatenate, 1 or 2
          // Outputs:
          //   C  output matrix
          //

    colon(...) method of builtins.PyCapsule instance
        colon(*args, **kwargs)
        Overloaded function.

        1. colon(low: float, step: float, high: float, I: pyigl.eigen.MatrixXd) -> None

        // Colon operator like matlab's colon operator. Enumerats values between low
          // and hi with step step.
          // Templates:
          //   L  should be a eigen matrix primitive type like int or double
          //   S  should be a eigen matrix primitive type like int or double
          //   H  should be a eigen matrix primitive type like int or double
          //   T  should be a eigen matrix primitive type like int or double
          // Inputs:
          //   low  starting value if step is valid then this is *always* the first
          //     element of I
          //   step  step difference between sequential elements returned in I,
          //     remember this will be cast to template T at compile time. If low<hi
          //     then step must be positive. If low>hi then step must be negative.
          //     Otherwise I will be set to empty.
          //   hi  ending value, if (hi-low)%step is zero then this will be the last
          //     element in I. If step is positive there will be no elements greater
          //     than hi, vice versa if hi<low
          // Output:
          //   I  list of values from low to hi with step size step

        2. colon(low: float, high: float, I: pyigl.eigen.MatrixXd) -> None

        // Colon operator like matlab's colon operator. Enumerats values between low
          // and hi with step step.
          // Templates:
          //   L  should be a eigen matrix primitive type like int or double
          //   S  should be a eigen matrix primitive type like int or double
          //   H  should be a eigen matrix primitive type like int or double
          //   T  should be a eigen matrix primitive type like int or double
          // Inputs:
          //   low  starting value if step is valid then this is *always* the first
          //     element of I
          //   step  step difference between sequential elements returned in I,
          //     remember this will be cast to template T at compile time. If low<hi
          //     then step must be positive. If low>hi then step must be negative.
          //     Otherwise I will be set to empty.
          //   hi  ending value, if (hi-low)%step is zero then this will be the last
          //     element in I. If step is positive there will be no elements greater
          //     than hi, vice versa if hi<low
          // Output:
          //   I  list of values from low to hi with step size step

        3. colon(low: float, high: float) -> pyigl.eigen.MatrixXd

        // Colon operator like matlab's colon operator. Enumerats values between low
          // and hi with step step.
          // Templates:
          //   L  should be a eigen matrix primitive type like int or double
          //   S  should be a eigen matrix primitive type like int or double
          //   H  should be a eigen matrix primitive type like int or double
          //   T  should be a eigen matrix primitive type like int or double
          // Inputs:
          //   low  starting value if step is valid then this is *always* the first
          //     element of I
          //   step  step difference between sequential elements returned in I,
          //     remember this will be cast to template T at compile time. If low<hi
          //     then step must be positive. If low>hi then step must be negative.
          //     Otherwise I will be set to empty.
          //   hi  ending value, if (hi-low)%step is zero then this will be the last
          //     element in I. If step is positive there will be no elements greater
          //     than hi, vice versa if hi<low
          // Output:
          //   I  list of values from low to hi with step size step

    coloni(...) method of builtins.PyCapsule instance
        coloni(*args, **kwargs)
        Overloaded function.

        1. coloni(low: int, step: int, high: int, I: pyigl.eigen.MatrixXi) -> None

        // Colon operator like matlab's colon operator. Enumerats values between low
          // and hi with step step.
          // Templates:
          //   L  should be a eigen matrix primitive type like int or double
          //   S  should be a eigen matrix primitive type like int or double
          //   H  should be a eigen matrix primitive type like int or double
          //   T  should be a eigen matrix primitive type like int or double
          // Inputs:
          //   low  starting value if step is valid then this is *always* the first
          //     element of I
          //   step  step difference between sequential elements returned in I,
          //     remember this will be cast to template T at compile time. If low<hi
          //     then step must be positive. If low>hi then step must be negative.
          //     Otherwise I will be set to empty.
          //   hi  ending value, if (hi-low)%step is zero then this will be the last
          //     element in I. If step is positive there will be no elements greater
          //     than hi, vice versa if hi<low
          // Output:
          //   I  list of values from low to hi with step size step

        2. coloni(low: int, high: int, I: pyigl.eigen.MatrixXi) -> None

        // Colon operator like matlab's colon operator. Enumerats values between low
          // and hi with step step.
          // Templates:
          //   L  should be a eigen matrix primitive type like int or double
          //   S  should be a eigen matrix primitive type like int or double
          //   H  should be a eigen matrix primitive type like int or double
          //   T  should be a eigen matrix primitive type like int or double
          // Inputs:
          //   low  starting value if step is valid then this is *always* the first
          //     element of I
          //   step  step difference between sequential elements returned in I,
          //     remember this will be cast to template T at compile time. If low<hi
          //     then step must be positive. If low>hi then step must be negative.
          //     Otherwise I will be set to empty.
          //   hi  ending value, if (hi-low)%step is zero then this will be the last
          //     element in I. If step is positive there will be no elements greater
          //     than hi, vice versa if hi<low
          // Output:
          //   I  list of values from low to hi with step size step

        3. coloni(low: int, high: int) -> pyigl.eigen.MatrixXi

        // Colon operator like matlab's colon operator. Enumerats values between low
          // and hi with step step.
          // Templates:
          //   L  should be a eigen matrix primitive type like int or double
          //   S  should be a eigen matrix primitive type like int or double
          //   H  should be a eigen matrix primitive type like int or double
          //   T  should be a eigen matrix primitive type like int or double
          // Inputs:
          //   low  starting value if step is valid then this is *always* the first
          //     element of I
          //   step  step difference between sequential elements returned in I,
          //     remember this will be cast to template T at compile time. If low<hi
          //     then step must be positive. If low>hi then step must be negative.
          //     Otherwise I will be set to empty.
          //   hi  ending value, if (hi-low)%step is zero then this will be the last
          //     element in I. If step is positive there will be no elements greater
          //     than hi, vice versa if hi<low
          // Output:
          //   I  list of values from low to hi with step size step

    column_to_quats(...) method of builtins.PyCapsule instance
        column_to_quats(Q: pyigl.eigen.MatrixXd, vQ: pyigl.RotationList) -> bool

        // "Columnize" a list of quaternions (q1x,q1y,q1z,q1w,q2x,q2y,q2z,q2w,...)
          //
          // Inputs:
          //   Q  n*4-long list of coefficients
          // Outputs:
          //   vQ  n-long list of quaternions
          // Returns false if n%4!=0

    comb_cross_field(...) method of builtins.PyCapsule instance
        comb_cross_field(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, PD1in: pyigl.eigen.MatrixXd, PD2in: pyigl.eigen.MatrixXd, PD1out: pyigl.eigen.MatrixXd, PD2out: pyigl.eigen.MatrixXd) -> None

        // Inputs:
          //   V          #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F          #F by 4 eigen Matrix of face (quad) indices
          //   PD1in      #F by 3 eigen Matrix of the first per face cross field vector
          //   PD2in      #F by 3 eigen Matrix of the second per face cross field vector
          // Output:
          //   PD1out      #F by 3 eigen Matrix of the first combed cross field vector
          //   PD2out      #F by 3 eigen Matrix of the second combed cross field vector
          //

    comb_frame_field(...) method of builtins.PyCapsule instance
        comb_frame_field(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, PD1: pyigl.eigen.MatrixXd, PD2: pyigl.eigen.MatrixXd, BIS1_combed: pyigl.eigen.MatrixXd, BIS2_combed: pyigl.eigen.MatrixXd, PD1_combed: pyigl.eigen.MatrixXd, PD2_combed: pyigl.eigen.MatrixXd) -> None

        // Inputs:
          //   V            #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F            #F by 4 eigen Matrix of face (quad) indices
          //   PD1          #F by 3 eigen Matrix of the first per face cross field vector
          //   PD2          #F by 3 eigen Matrix of the second per face cross field vector
          //   BIS1_combed  #F by 3 eigen Matrix of the first combed bisector field vector
          //   BIS2_combed  #F by 3 eigen Matrix of the second combed bisector field vector
          // Output:
          //   PD1_combed  #F by 3 eigen Matrix of the first combed cross field vector
          //   PD2_combed  #F by 3 eigen Matrix of the second combed cross field vector
          //

    compute_frame_field_bisectors(...) method of builtins.PyCapsule instance
        compute_frame_field_bisectors(*args, **kwargs)
        Overloaded function.

        1. compute_frame_field_bisectors(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, B1: pyigl.eigen.MatrixXd, B2: pyigl.eigen.MatrixXd, PD1: pyigl.eigen.MatrixXd, PD2: pyigl.eigen.MatrixXd, BIS1: pyigl.eigen.MatrixXd, BIS2: pyigl.eigen.MatrixXd) -> None

        // Compute bisectors of a frame field defined on mesh faces
          // Inputs:
          //   V     #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F     #F by 3 eigen Matrix of face (triangle) indices
          //   B1    #F by 3 eigen Matrix of face (triangle) base vector 1
          //   B2    #F by 3 eigen Matrix of face (triangle) base vector 2
          //   PD1   #F by 3 eigen Matrix of the first per face frame field vector
          //   PD2   #F by 3 eigen Matrix of the second per face frame field vector
          // Output:
          //   BIS1  #F by 3 eigen Matrix of the first per face frame field bisector
          //   BIS2  #F by 3 eigen Matrix of the second per face frame field bisector
          //

        2. compute_frame_field_bisectors(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, PD1: pyigl.eigen.MatrixXd, PD2: pyigl.eigen.MatrixXd, BIS1: pyigl.eigen.MatrixXd, BIS2: pyigl.eigen.MatrixXd) -> None

        // Compute bisectors of a frame field defined on mesh faces
          // Inputs:
          //   V     #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F     #F by 3 eigen Matrix of face (triangle) indices
          //   B1    #F by 3 eigen Matrix of face (triangle) base vector 1
          //   B2    #F by 3 eigen Matrix of face (triangle) base vector 2
          //   PD1   #F by 3 eigen Matrix of the first per face frame field vector
          //   PD2   #F by 3 eigen Matrix of the second per face frame field vector
          // Output:
          //   BIS1  #F by 3 eigen Matrix of the first per face frame field bisector
          //   BIS2  #F by 3 eigen Matrix of the second per face frame field bisector
          //

    cotmatrix(...) method of builtins.PyCapsule instance
        cotmatrix(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, L: pyigl.eigen.SparseMatrixd) -> None

        // Constructs the cotangent stiffness matrix (discrete laplacian) for a given
          // mesh (V,F).
          //
          // Templates:
          //   DerivedV  derived type of eigen matrix for V (e.g. derived from
          //     MatrixXd)
          //   DerivedF  derived type of eigen matrix for F (e.g. derived from
          //     MatrixXi)
          //   Scalar  scalar type for eigen sparse matrix (e.g. double)
          // Inputs:
          //   V  #V by dim list of mesh vertex positions
          //   F  #F by simplex_size list of mesh faces (must be triangles)
          // Outputs:
          //   L  #V by #V cotangent matrix, each row i corresponding to V(i,:)
          //
          // See also: adjacency_matrix
          //
          // Note: This Laplacian uses the convention that diagonal entries are
          // **minus** the sum of off-diagonal entries. The diagonal entries are
          // therefore in general negative and the matrix is **negative** semi-definite
          // (immediately, -L is **positive** semi-definite)
          //

    covariance_scatter_matrix(...) method of builtins.PyCapsule instance
        covariance_scatter_matrix(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, energy: pyigl.ARAPEnergyType, CSM: pyigl.eigen.SparseMatrixd) -> None

        // Construct the covariance scatter matrix for a given arap energy
          // Inputs:
          //   V  #V by Vdim list of initial domain positions
          //   F  #F by 3 list of triangle indices into V
          //   energy  ARAPEnergyType enum value defining which energy is being used.
          //     See ARAPEnergyType.h for valid options and explanations.
          // Outputs:
          //   CSM dim*#V/#F by dim*#V sparse matrix containing special laplacians along
          //     the diagonal so that when multiplied by V gives covariance matrix
          //     elements, can be used to speed up covariance matrix computation

    cross_field_missmatch(...) method of builtins.PyCapsule instance
        cross_field_missmatch(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, PD1: pyigl.eigen.MatrixXd, PD2: pyigl.eigen.MatrixXd, isCombed: bool, missmatch: pyigl.eigen.MatrixXi) -> None

        // Inputs:
          //   V         #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F         #F by 3 eigen Matrix of face (quad) indices
          //   PD1       #F by 3 eigen Matrix of the first per face cross field vector
          //   PD2       #F by 3 eigen Matrix of the second per face cross field vector
          //   isCombed  boolean, specifying whether the field is combed (i.e. matching has been precomputed.
          //             If not, the field is combed first.
          // Output:
          //   Handle_MMatch    #F by 3 eigen Matrix containing the integer missmatch of the cross field
          //                    across all face edges
          //

    cut_mesh_from_singularities(...) method of builtins.PyCapsule instance
        cut_mesh_from_singularities(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, MMatch: pyigl.eigen.MatrixXi, seams: pyigl.eigen.MatrixXi) -> None

        // Given a mesh (V,F) and the integer mismatch of a cross field per edge
          // (MMatch), finds the cut_graph connecting the singularities (seams) and the
          // degree of the singularities singularity_index
          //
          // Input:
          //   V  #V by 3 list of mesh vertex positions
          //   F  #F by 3 list of faces
          //   MMatch  #F by 3 list of per corner integer mismatch
          // Outputs:
          //   seams  #F by 3 list of per corner booleans that denotes if an edge is a
          //     seam or not
          //

    deform_skeleton(...) method of builtins.PyCapsule instance
        deform_skeleton(C: pyigl.eigen.MatrixXd, BE: pyigl.eigen.MatrixXi, T: pyigl.eigen.MatrixXd, CT: pyigl.eigen.MatrixXd, BET: pyigl.eigen.MatrixXi) -> None

        // Deform a skeleton.
          //
          // Inputs:
          //   C  #C by 3 list of joint positions
          //   BE  #BE by 2 list of bone edge indices
          //   vA  #BE list of bone transformations
          // Outputs
          //   CT  #BE*2 by 3 list of deformed joint positions
          //   BET  #BE by 2 list of bone edge indices (maintains order)
          //

    directed_edge_orientations(...) method of builtins.PyCapsule instance
        directed_edge_orientations(C: pyigl.eigen.MatrixXd, E: pyigl.eigen.MatrixXi, Q: pyigl.RotationList) -> None

        // Determine rotations that take each edge from the x-axis to its given rest
          // orientation.
          //
          // Inputs:
          //   C  #C by 3 list of edge vertex positions
          //   E  #E by 2 list of directed edges
          // Outputs:
          //   Q  #E list of quaternions
          //

    directed_edge_parents(...) method of builtins.PyCapsule instance
        directed_edge_parents(E: pyigl.eigen.MatrixXi, P: pyigl.eigen.MatrixXi) -> None

        // Recover "parents" (preceding edges) in a tree given just directed edges.
          //
          // Inputs:
          //   E  #E by 2 list of directed edges
          // Outputs:
          //   P  #E list of parent indices into E (-1) means root
          //

    doublearea(...) method of builtins.PyCapsule instance
        doublearea(*args, **kwargs)
        Overloaded function.

        1. doublearea(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, dblA: pyigl.eigen.MatrixXd) -> None

        // DOUBLEAREA computes twice the area for each input triangle[quad]
          //
          // Templates:
          //   DerivedV  derived type of eigen matrix for V (e.g. derived from
          //     MatrixXd)
          //   DerivedF  derived type of eigen matrix for F (e.g. derived from
          //     MatrixXi)
          //   DeriveddblA  derived type of eigen matrix for dblA (e.g. derived from
          //     MatrixXd)
          // Inputs:
          //   V  #V by dim list of mesh vertex positions
          //   F  #F by simplex_size list of mesh faces (must be triangles or quads)
          // Outputs:
          //   dblA  #F list of triangle[quad] double areas (SIGNED only for 2D input)
          //
          // Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal
          // if you have 1million unreferenced vertices and 1 face

        2. doublearea(A: pyigl.eigen.MatrixXd, B: pyigl.eigen.MatrixXd, C: pyigl.eigen.MatrixXd, D: pyigl.eigen.MatrixXd) -> None

        // DOUBLEAREA computes twice the area for each input triangle[quad]
          //
          // Templates:
          //   DerivedV  derived type of eigen matrix for V (e.g. derived from
          //     MatrixXd)
          //   DerivedF  derived type of eigen matrix for F (e.g. derived from
          //     MatrixXi)
          //   DeriveddblA  derived type of eigen matrix for dblA (e.g. derived from
          //     MatrixXd)
          // Inputs:
          //   V  #V by dim list of mesh vertex positions
          //   F  #F by simplex_size list of mesh faces (must be triangles or quads)
          // Outputs:
          //   dblA  #F list of triangle[quad] double areas (SIGNED only for 2D input)
          //
          // Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal
          // if you have 1million unreferenced vertices and 1 face

        3. doublearea(l: pyigl.eigen.MatrixXd, dblA: pyigl.eigen.MatrixXd) -> None

        // DOUBLEAREA computes twice the area for each input triangle[quad]
          //
          // Templates:
          //   DerivedV  derived type of eigen matrix for V (e.g. derived from
          //     MatrixXd)
          //   DerivedF  derived type of eigen matrix for F (e.g. derived from
          //     MatrixXi)
          //   DeriveddblA  derived type of eigen matrix for dblA (e.g. derived from
          //     MatrixXd)
          // Inputs:
          //   V  #V by dim list of mesh vertex positions
          //   F  #F by simplex_size list of mesh faces (must be triangles or quads)
          // Outputs:
          //   dblA  #F list of triangle[quad] double areas (SIGNED only for 2D input)
          //
          // Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal
          // if you have 1million unreferenced vertices and 1 face

    doublearea_quad(...) method of builtins.PyCapsule instance
        doublearea_quad(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, dblA: pyigl.eigen.MatrixXd) -> None

        // DOUBLEAREA_QUAD computes twice the area for each input quadrilateral
          //
          // Inputs:
          //   V  #V by dim list of mesh vertex positions
          //   F  #F by simplex_size list of mesh faces (must be quadrilaterals)
          // Outputs:
          //   dblA  #F list of quadrilateral double areas
          //

    doublearea_single(...) method of builtins.PyCapsule instance
        doublearea_single(A: pyigl.eigen.MatrixXd, B: pyigl.eigen.MatrixXd, C: pyigl.eigen.MatrixXd) -> float

        // Single triangle in 2D!
          //
          // This should handle streams of corners not just single corners

    dqs(...) method of builtins.PyCapsule instance
        dqs(V: pyigl.eigen.MatrixXd, W: pyigl.eigen.MatrixXd, vQ: pyigl.RotationList, vT: List[pyigl.eigen.MatrixXd], U: pyigl.eigen.MatrixXd) -> None

        // Dual quaternion skinning
          //
          // Inputs:
          //   V  #V by 3 list of rest positions
          //   W  #W by #C list of weights
          //   vQ  #C list of rotation quaternions
          //   vT  #C list of translation vectors
          // Outputs:
          //   U  #V by 3 list of new positions

    edge_lengths(...) method of builtins.PyCapsule instance
        edge_lengths(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, L: pyigl.eigen.MatrixXd) -> None

        // Constructs a list of lengths of edges opposite each index in a face
          // (triangle/tet) list
          //
          // Templates:
          //   DerivedV derived from vertex positions matrix type: i.e. MatrixXd
          //   DerivedF derived from face indices matrix type: i.e. MatrixXi
          //   DerivedL derived from edge lengths matrix type: i.e. MatrixXd
          // Inputs:
          //   V  eigen matrix #V by 3
          //   F  #F by 2 list of mesh edges
          //    or
          //   F  #F by 3 list of mesh faces (must be triangles)
          //    or
          //   T  #T by 4 list of mesh elements (must be tets)
          // Outputs:
          //   L  #F by {1|3|6} list of edge lengths
          //     for edges, column of lengths
          //     for triangles, columns correspond to edges [1,2],[2,0],[0,1]
          //     for tets, columns correspond to edges
          //     [3 0],[3 1],[3 2],[1 2],[2 0],[0 1]
          //

    edge_topology(...) method of builtins.PyCapsule instance
        edge_topology(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, EV: pyigl.eigen.MatrixXi, FE: pyigl.eigen.MatrixXi, EF: pyigl.eigen.MatrixXi) -> None

        // Constructs a list of lengths of edges opposite each index in a face
          // (triangle/tet) list
          //
          // Templates:
          //   DerivedV derived from vertex positions matrix type: i.e. MatrixXd
          //   DerivedF derived from face indices matrix type: i.e. MatrixXi
          //   DerivedL derived from edge lengths matrix type: i.e. MatrixXd
          // Inputs:
          //   V  eigen matrix #V by 3
          //   F  #F by 2 list of mesh edges
          //    or
          //   F  #F by 3 list of mesh faces (must be triangles)
          //    or
          //   T  #T by 4 list of mesh elements (must be tets)
          // Outputs:
          //   L  #F by {1|3|6} list of edge lengths
          //     for edges, column of lengths
          //     for triangles, columns correspond to edges [1,2],[2,0],[0,1]
          //     for tets, columns correspond to edges
          //     [3 0],[3 1],[3 2],[1 2],[2 0],[0 1]
          //

    eigs(...) method of builtins.PyCapsule instance
        eigs(A: pyigl.eigen.SparseMatrixd, B: pyigl.eigen.SparseMatrixd, k: int, type: pyigl.EigsType, sU: pyigl.eigen.MatrixXd, sS: pyigl.eigen.MatrixXd) -> bool

        See eigs for the documentation.

    exact_geodesic(...) method of builtins.PyCapsule instance
        exact_geodesic(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, VS: pyigl.eigen.MatrixXi, FS: pyigl.eigen.MatrixXi, VT: pyigl.eigen.MatrixXi, FT: pyigl.eigen.MatrixXi, D: pyigl.eigen.MatrixXd) -> None


        // Exact geodesic algorithm for triangular mesh with the implementation from https://code.google.com/archive/p/geodesic/,
        // and the algorithm first described by Mitchell, Mount and Papadimitriou in 1987
        //
        // Inputs:
        //   V  #V by 3 list of 3D vertex positions
        //   F  #F by 3 list of mesh faces
        //   VS #VS by 1 vector specifying indices of source vertices
        //   FS #FS by 1 vector specifying indices of source faces
        //   VT #VT by 1 vector specifying indices of target vertices
        //   FT #FT by 1 vector specifying indices of target faces
        // Output:
        //   D  #VT+#FT by 1 vector of geodesic distances of each target w.r.t. the nearest one in the source set
        //
        // Note:
        //      Specifying a face as target/source means its center.
        //

    find_cross_field_singularities(...) method of builtins.PyCapsule instance
        find_cross_field_singularities(*args, **kwargs)
        Overloaded function.

        1. find_cross_field_singularities(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, Handle_MMatch: pyigl.eigen.MatrixXi, isSingularity: pyigl.eigen.MatrixXi, singularityIndex: pyigl.eigen.MatrixXi) -> None

        // Inputs:
          //   V                #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F                #F by 3 eigen Matrix of face (quad) indices
          //   Handle_MMatch    #F by 3 eigen Matrix containing the integer missmatch of the cross field
          //                    across all face edges
          // Output:
          //   isSingularity    #V by 1 boolean eigen Vector indicating the presence of a singularity on a vertex
          //   singularityIndex #V by 1 integer eigen Vector containing the singularity indices
          //

        2. find_cross_field_singularities(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, PD1: pyigl.eigen.MatrixXd, PD2: pyigl.eigen.MatrixXd, isSingularity: pyigl.eigen.MatrixXi, singularityIndex: pyigl.eigen.MatrixXi, isCombed: bool = False) -> None

        // Inputs:
          //   V                #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F                #F by 3 eigen Matrix of face (quad) indices
          //   Handle_MMatch    #F by 3 eigen Matrix containing the integer missmatch of the cross field
          //                    across all face edges
          // Output:
          //   isSingularity    #V by 1 boolean eigen Vector indicating the presence of a singularity on a vertex
          //   singularityIndex #V by 1 integer eigen Vector containing the singularity indices
          //

    fit_rotations(...) method of builtins.PyCapsule instance
        fit_rotations(S: pyigl.eigen.MatrixXd, single_precision: bool, R: pyigl.eigen.MatrixXd) -> None

        // Known issues: This seems to be implemented in Eigen/Geometry:
          // Eigen::umeyama
          //
          // FIT_ROTATIONS Given an input mesh and new positions find rotations for
          // every covariance matrix in a stack of covariance matrices
          //
          // Inputs:
          //   S  nr*dim by dim stack of covariance matrices
          //   single_precision  whether to use single precision (faster)
          // Outputs:
          //   R  dim by dim * nr list of rotations
          //

    fit_rotations_planar(...) method of builtins.PyCapsule instance
        fit_rotations_planar(S: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXd) -> None

        // FIT_ROTATIONS Given an input mesh and new positions find 2D rotations for
          // every vertex that best maps its one ring to the new one ring
          //
          // Inputs:
          //   S  nr*dim by dim stack of covariance matrices, third column and every
          //   third row will be ignored
          // Outputs:
          //   R  dim by dim * nr list of rotations, third row and third column of each
          //   rotation will just be identity
          //

    floor(...) method of builtins.PyCapsule instance
        floor(X: pyigl.eigen.MatrixXd, Y: pyigl.eigen.MatrixXi) -> None

        // Floor a given matrix to nearest integers
          //
          // Inputs:
          //   X  m by n matrix of scalars
          // Outputs:
          //   Y  m by n matrix of floored integers

    forward_kinematics(...) method of builtins.PyCapsule instance
        forward_kinematics(C: pyigl.eigen.MatrixXd, BE: pyigl.eigen.MatrixXi, P: pyigl.eigen.MatrixXi, dQ: pyigl.RotationList, vQ: pyigl.RotationList, vT: list) -> None

        // Given a skeleton and a set of relative bone rotations compute absolute
          // rigid transformations for each bone.
          //
          // Inputs:
          //   C  #C by dim list of joint positions
          //   BE  #BE by 2 list of bone edge indices
          //   P  #BE list of parent indices into BE
          //   dQ  #BE list of relative rotations
          //   dT  #BE list of relative translations
          // Outputs:
          //   vQ  #BE list of absolute rotations
          //   vT  #BE list of absolute translations

    gaussian_curvature(...) method of builtins.PyCapsule instance
        gaussian_curvature(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, K: pyigl.eigen.MatrixXd) -> None

        // Compute discrete local integral gaussian curvature (angle deficit, without
          // averaging by local area).
          //
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigen Matrix of face (triangle) indices
          // Output:
          //   K  #V by 1 eigen Matrix of discrete gaussian curvature values
          //

    get_seconds(...) method of builtins.PyCapsule instance
        get_seconds() -> float

        // Return the current time in seconds since program start
          //
          // Example:
          //    const auto & tictoc = []()
          //    {
          //      static double t_start = igl::get_seconds();
          //      double diff = igl::get_seconds()-t_start;
          //      t_start += diff;
          //      return diff;
          //    };
          //    tictoc();
          //    ... // part 1
          //    cout<<"part 1: "<<tictoc()<<endl;
          //    ... // part 2
          //    cout<<"part 2: "<<tictoc()<<endl;
          //    ... // etc

    grad(...) method of builtins.PyCapsule instance
        grad(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, G: pyigl.eigen.SparseMatrixd) -> None

        // Gradient of a scalar function defined on piecewise linear elements (mesh)
          // is constant on each triangle [tetrahedron] i,j,k:
          // grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A
          // where Xi is the scalar value at vertex i, Vi is the 3D position of vertex
          // i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of
          // 90 degrees
          //

    harmonic(...) method of builtins.PyCapsule instance
        harmonic(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, b: pyigl.eigen.MatrixXi, bc: pyigl.eigen.MatrixXd, k: int, W: pyigl.eigen.MatrixXd) -> bool

        // Compute k-harmonic weight functions "coordinates".
          //
          //
          // Inputs:
          //   V  #V by dim vertex positions
          //   F  #F by simplex-size list of element indices
          //   b  #b boundary indices into V
          //   bc #b by #W list of boundary values
          //   k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)
          // Outputs:
          //   W  #V by #W list of weights
          //

    hsv_to_rgb(...) method of builtins.PyCapsule instance
        hsv_to_rgb(H: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXd) -> None

        // Convert RGB to HSV
          //
          // Inputs:
          //   h  hue value (degrees: [0,360])
          //   s  saturation value ([0,1])
          //   v  value value ([0,1])
          // Outputs:
          //   r  red value ([0,1])
          //   g  green value ([0,1])
          //   b  blue value ([0,1])

    internal_angles(...) method of builtins.PyCapsule instance
        internal_angles(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, K: pyigl.eigen.MatrixXd) -> None

        // Compute internal angles for a triangle mesh
          //
          // Inputs:
          //   V  #V by dim eigen Matrix of mesh vertex nD positions
          //   F  #F by poly-size eigen Matrix of face (triangle) indices
          // Output:
          //   K  #F by poly-size eigen Matrix of internal angles
          //     for triangles, columns correspond to edges [1,2],[2,0],[0,1]
          //
          // Known Issues:
          //   if poly-size  3 then dim must equal 3.

    internal_angles_using_squared_edge_lengths(...) method of builtins.PyCapsule instance
        internal_angles_using_squared_edge_lengths(L_sq: pyigl.eigen.MatrixXd, K: pyigl.eigen.MatrixXd) -> None

        // Compute internal angles for a triangle mesh
          //
          // Inputs:
          //   V  #V by dim eigen Matrix of mesh vertex nD positions
          //   F  #F by poly-size eigen Matrix of face (triangle) indices
          // Output:
          //   K  #F by poly-size eigen Matrix of internal angles
          //     for triangles, columns correspond to edges [1,2],[2,0],[0,1]
          //
          // Known Issues:
          //   if poly-size  3 then dim must equal 3.

    invert_diag(...) method of builtins.PyCapsule instance
        invert_diag(X: pyigl.eigen.SparseMatrixd, Y: pyigl.eigen.SparseMatrixd) -> None

        // Templates:
          //   T  should be a eigen sparse matrix primitive type like int or double
          // Inputs:
          //   X  an m by n sparse matrix
          // Outputs:
          //   Y  an m by n sparse matrix

    is_irregular_vertex(...) method of builtins.PyCapsule instance
        is_irregular_vertex(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi) -> List[bool]

        // Determine if a vertex is irregular, i.e. it has more than 6 (triangles)
          // or 4 (quads) incident edges. Vertices on the boundary are ignored.
          //
          // Inputs:
          //   V  #V by dim list of vertex positions
          //   F  #F by 3[4] list of triangle[quads] indices
          // Returns #V vector of bools revealing whether vertices are singular
          //

    jet(...) method of builtins.PyCapsule instance
        jet(*args, **kwargs)
        Overloaded function.

        1. jet(Z: pyigl.eigen.MatrixXd, normalize: bool, C: pyigl.eigen.MatrixXd) -> None

        // JET like MATLAB's jet
          //
          // Inputs:
          //   m  number of colors
          // Outputs:
          //   J  m by list of RGB colors between 0 and 1
          //
        //#ifndef IGL_NO_EIGEN
        //  void jet(const int m, Eigen::MatrixXd & J);
        //#endif
          // Wrapper for directly computing [r,g,b] values for a given factor f between
          // 0 and 1
          //
          // Inputs:
          //   f  factor determining color value as if 0 was min and 1 was max
          // Outputs:
          //   r  red value
          //   g  green value
          //   b  blue value

        2. jet(Z: pyigl.eigen.MatrixXd, min_Z: float, max_Z: float, C: pyigl.eigen.MatrixXd) -> None

        // JET like MATLAB's jet
          //
          // Inputs:
          //   m  number of colors
          // Outputs:
          //   J  m by list of RGB colors between 0 and 1
          //
        //#ifndef IGL_NO_EIGEN
        //  void jet(const int m, Eigen::MatrixXd & J);
        //#endif
          // Wrapper for directly computing [r,g,b] values for a given factor f between
          // 0 and 1
          //
          // Inputs:
          //   f  factor determining color value as if 0 was min and 1 was max
          // Outputs:
          //   r  red value
          //   g  green value
          //   b  blue value

    lbs_matrix(...) method of builtins.PyCapsule instance
        lbs_matrix(V: pyigl.eigen.MatrixXd, W: pyigl.eigen.MatrixXd, M: pyigl.eigen.MatrixXd) -> None

        // LBS_MATRIX Linear blend skinning can be expressed by V' = M * T where V' is
          // a #V by dim matrix of deformed vertex positions (one vertex per row), M is a
          // #V by (dim+1)*#T (composed of weights and rest positions) and T is a
          // #T*(dim+1) by dim matrix of #T stacked transposed transformation matrices.
          // See equations (1) and (2) in "Fast Automatic Skinning Transformations"
          // [Jacobson et al 2012]
          //
          // Inputs:
          //   V  #V by dim list of rest positions
          //   W  #V+ by #T  list of weights
          // Outputs:
          //   M  #V by #T*(dim+1)
          //
          // In MATLAB:
          //   kron(ones(1,size(W,2)),[V ones(size(V,1),1)]).*kron(W,ones(1,size(V,2)+1))

    lbs_matrix_column(...) method of builtins.PyCapsule instance
        lbs_matrix_column(*args, **kwargs)
        Overloaded function.

        1. lbs_matrix_column(V: pyigl.eigen.MatrixXd, W: pyigl.eigen.MatrixXd, M: pyigl.eigen.MatrixXd) -> None

        // LBS_MATRIX  construct a matrix that when multiplied against a column of
          // affine transformation entries computes new coordinates of the vertices
          //
          // I'm not sure it makes since that the result is stored as a sparse matrix.
          // The number of non-zeros per row *is* dependent on the number of mesh
          // vertices and handles.
          //
          // Inputs:
          //   V  #V by dim list of vertex rest positions
          //   W  #V by #handles list of correspondence weights
          // Output:
          //   M  #V * dim by #handles * dim * (dim+1) matrix such that
          //     new_V(:) = LBS(V,W,A) = reshape(M * A,size(V)), where A is a column
          //     vectors formed by the entries in each handle's dim by dim+1
          //     transformation matrix. Specifcally, A =
          //       reshape(permute(Astack,[3 1 2]),n*dim*(dim+1),1)
          //     or A = [Lxx;Lyx;Lxy;Lyy;tx;ty], and likewise for other dim
          //     if Astack(:,:,i) is the dim by (dim+1) transformation at handle i

        2. lbs_matrix_column(V: pyigl.eigen.MatrixXd, W: pyigl.eigen.MatrixXd, WI: pyigl.eigen.MatrixXi, M: pyigl.eigen.MatrixXd) -> None

        // LBS_MATRIX  construct a matrix that when multiplied against a column of
          // affine transformation entries computes new coordinates of the vertices
          //
          // I'm not sure it makes since that the result is stored as a sparse matrix.
          // The number of non-zeros per row *is* dependent on the number of mesh
          // vertices and handles.
          //
          // Inputs:
          //   V  #V by dim list of vertex rest positions
          //   W  #V by #handles list of correspondence weights
          // Output:
          //   M  #V * dim by #handles * dim * (dim+1) matrix such that
          //     new_V(:) = LBS(V,W,A) = reshape(M * A,size(V)), where A is a column
          //     vectors formed by the entries in each handle's dim by dim+1
          //     transformation matrix. Specifcally, A =
          //       reshape(permute(Astack,[3 1 2]),n*dim*(dim+1),1)
          //     or A = [Lxx;Lyx;Lxy;Lyy;tx;ty], and likewise for other dim
          //     if Astack(:,:,i) is the dim by (dim+1) transformation at handle i

        3. lbs_matrix_column(V: pyigl.eigen.MatrixXd, W: pyigl.eigen.MatrixXd, M: pyigl.eigen.SparseMatrixd) -> None

        // LBS_MATRIX  construct a matrix that when multiplied against a column of
          // affine transformation entries computes new coordinates of the vertices
          //
          // I'm not sure it makes since that the result is stored as a sparse matrix.
          // The number of non-zeros per row *is* dependent on the number of mesh
          // vertices and handles.
          //
          // Inputs:
          //   V  #V by dim list of vertex rest positions
          //   W  #V by #handles list of correspondence weights
          // Output:
          //   M  #V * dim by #handles * dim * (dim+1) matrix such that
          //     new_V(:) = LBS(V,W,A) = reshape(M * A,size(V)), where A is a column
          //     vectors formed by the entries in each handle's dim by dim+1
          //     transformation matrix. Specifcally, A =
          //       reshape(permute(Astack,[3 1 2]),n*dim*(dim+1),1)
          //     or A = [Lxx;Lyx;Lxy;Lyy;tx;ty], and likewise for other dim
          //     if Astack(:,:,i) is the dim by (dim+1) transformation at handle i

        4. lbs_matrix_column(V: pyigl.eigen.MatrixXd, W: pyigl.eigen.MatrixXd, WI: pyigl.eigen.MatrixXi, M: pyigl.eigen.SparseMatrixd) -> None

        // LBS_MATRIX  construct a matrix that when multiplied against a column of
          // affine transformation entries computes new coordinates of the vertices
          //
          // I'm not sure it makes since that the result is stored as a sparse matrix.
          // The number of non-zeros per row *is* dependent on the number of mesh
          // vertices and handles.
          //
          // Inputs:
          //   V  #V by dim list of vertex rest positions
          //   W  #V by #handles list of correspondence weights
          // Output:
          //   M  #V * dim by #handles * dim * (dim+1) matrix such that
          //     new_V(:) = LBS(V,W,A) = reshape(M * A,size(V)), where A is a column
          //     vectors formed by the entries in each handle's dim by dim+1
          //     transformation matrix. Specifcally, A =
          //       reshape(permute(Astack,[3 1 2]),n*dim*(dim+1),1)
          //     or A = [Lxx;Lyx;Lxy;Lyy;tx;ty], and likewise for other dim
          //     if Astack(:,:,i) is the dim by (dim+1) transformation at handle i

    local_basis(...) method of builtins.PyCapsule instance
        local_basis(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, B1: pyigl.eigen.MatrixXd, B2: pyigl.eigen.MatrixXd, B3: pyigl.eigen.MatrixXd) -> None

        // Compute a local orthogonal reference system for each triangle in the given mesh
          // Templates:
          //   DerivedV derived from vertex positions matrix type: i.e. MatrixXd
          //   DerivedF derived from face indices matrix type: i.e. MatrixXi
          // Inputs:
          //   V  eigen matrix #V by 3
          //   F  #F by 3 list of mesh faces (must be triangles)
          // Outputs:
          //   B1 eigen matrix #F by 3, each vector is tangent to the triangle
          //   B2 eigen matrix #F by 3, each vector is tangent to the triangle and perpendicular to B1
          //   B3 eigen matrix #F by 3, normal of the triangle
          //
          // See also: adjacency_matrix

    lscm(...) method of builtins.PyCapsule instance
        lscm(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, b: pyigl.eigen.MatrixXi, bc: pyigl.eigen.MatrixXd, V_uv: pyigl.eigen.MatrixXd) -> bool

        // Compute a Least-squares conformal map parametrization (equivalently
          // derived in "Intrinsic Parameterizations of Surface Meshes" [Desbrun et al.
          // 2002] and "Least Squares Conformal Maps for Automatic Texture Atlas
          // Generation" [Lvy et al. 2002]), though this implementation follows the
          // derivation in: "Spectral Conformal Parameterization" [Mullen et al. 2008]
          // (note, this does **not** implement the Eigen-decomposition based method in
          // [Mullen et al. 2008], which is not equivalent). Input should be a manifold
          // mesh (also no unreferenced vertices) and "boundary" (fixed vertices) `b`
          // should contain at least two vertices per connected component.
          //
          // Inputs:
          //   V  #V by 3 list of mesh vertex positions
          //   F  #F by 3 list of mesh faces (must be triangles)
          //   b  #b boundary indices into V
          //   bc #b by 3 list of boundary values
          // Outputs:
          //   UV #V by 2 list of 2D mesh vertex positions in UV space
          // Returns true only on solver success.
          //

    map_vertices_to_circle(...) method of builtins.PyCapsule instance
        map_vertices_to_circle(V: pyigl.eigen.MatrixXd, bnd: pyigl.eigen.MatrixXi, UV: pyigl.eigen.MatrixXd) -> None

        // Map the vertices whose indices are in a given boundary loop (bnd) on the
          // unit circle with spacing proportional to the original boundary edge
          // lengths.
          //
          // Inputs:
          //   V  #V by dim list of mesh vertex positions
          //   b  #W list of vertex ids
          // Outputs:
          //   UV   #W by 2 list of 2D position on the unit circle for the vertices in b

    marching_tets(...) method of builtins.PyCapsule instance
        marching_tets(V: pyigl.eigen.MatrixXd, T: pyigl.eigen.MatrixXi, plane: pyigl.eigen.MatrixXd, U: pyigl.eigen.MatrixXd, G: pyigl.eigen.MatrixXi, J: pyigl.eigen.MatrixXi, BC: pyigl.eigen.SparseMatrixd) -> None

        // SLICE_TETS Slice through a tet mesh (V,T) along a given plane (via its
          // implicit equation).
          //
          // Inputs:
          //   V  #V by 3 list of tet mesh vertices
          //   T  #T by 4 list of tet indices into V
          //   plane  list of 4 coefficients in the plane equation: [x y z 1]'*plane = 0
          //   Optional:
          //     'Manifold' followed by whether to stitch together triangles into a
          //       manifold mesh {true}: results in more compact U but slightly slower.
          // Outputs:
          //   U  #U by 3 list of triangle mesh vertices along slice
          //   G  #G by 3 list of triangles indices into U
          //   J  #G list of indices into T revealing from which tet each faces comes
          //   BC  #U by #V list of barycentric coordinates (or more generally: linear
          //     interpolation coordinates) so that U = BC*V
          //

    massmatrix(...) method of builtins.PyCapsule instance
        massmatrix(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, type: pyigl.MassMatrixType, M: pyigl.eigen.SparseMatrixd) -> None

        // Constructs the mass (area) matrix for a given mesh (V,F).
          //
          // Templates:
          //   DerivedV  derived type of eigen matrix for V (e.g. derived from
          //     MatrixXd)
          //   DerivedF  derived type of eigen matrix for F (e.g. derived from
          //     MatrixXi)
          //   Scalar  scalar type for eigen sparse matrix (e.g. double)
          // Inputs:
          //   V  #V by dim list of mesh vertex positions
          //   F  #F by simplex_size list of mesh faces (must be triangles)
          //   type  one of the following ints:
          //     MASSMATRIX_TYPE_BARYCENTRIC  barycentric
          //     MASSMATRIX_TYPE_VORONOI voronoi-hybrid {default}
          //     MASSMATRIX_TYPE_FULL full {not implemented}
          // Outputs:
          //   M  #V by #V mass matrix
          //
          // See also: adjacency_matrix
          //

    min_quad_with_fixed(...) method of builtins.PyCapsule instance
        min_quad_with_fixed(A: pyigl.eigen.SparseMatrixd, B: pyigl.eigen.MatrixXd, known: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXd, Aeq: pyigl.eigen.SparseMatrixd, Beq: pyigl.eigen.MatrixXd, pd: bool, Z: pyigl.eigen.MatrixXd) -> bool

        See min_quad_with_fixed for the documentation.

    min_quad_with_fixed_precompute(...) method of builtins.PyCapsule instance
        min_quad_with_fixed_precompute(A: pyigl.eigen.SparseMatrixd, known: pyigl.eigen.MatrixXi, Aeq: pyigl.eigen.SparseMatrixd, pd: bool, data: pyigl.min_quad_with_fixed_data) -> bool

        See min_quad_with_fixed for the documentation.

    min_quad_with_fixed_solve(...) method of builtins.PyCapsule instance
        min_quad_with_fixed_solve(*args, **kwargs)
        Overloaded function.

        1. min_quad_with_fixed_solve(data: pyigl.min_quad_with_fixed_data, B: pyigl.eigen.MatrixXd, Y: pyigl.eigen.MatrixXd, Beq: pyigl.eigen.MatrixXd, Z: pyigl.eigen.MatrixXd, sol: pyigl.eigen.MatrixXd) -> bool

        See min_quad_with_fixed for the documentation.

        2. min_quad_with_fixed_solve(data: pyigl.min_quad_with_fixed_data, B: pyigl.eigen.MatrixXd, Y: pyigl.eigen.MatrixXd, Beq: pyigl.eigen.MatrixXd, Z: pyigl.eigen.MatrixXd) -> bool

        See min_quad_with_fixed for the documentation.

    normalize_row_lengths(...) method of builtins.PyCapsule instance
        normalize_row_lengths(A: pyigl.eigen.MatrixXd, B: pyigl.eigen.MatrixXd) -> None

        // Obsolete: just use A.rowwise().normalize() or B=A.rowwise().normalized();
          //
          // Normalize the rows in A so that their lengths are each 1 and place the new
          // entries in B
          // Inputs:
          //   A  #rows by k input matrix
          // Outputs:
          //   B  #rows by k input matrix, can be the same as A

    normalize_row_sums(...) method of builtins.PyCapsule instance
        normalize_row_sums(A: pyigl.eigen.MatrixXd, B: pyigl.eigen.MatrixXd) -> None

        // Normalize the rows in A so that their sums are each 1 and place the new
          // entries in B
          // Inputs:
          //   A  #rows by k input matrix
          // Outputs:
          //   B  #rows by k input matrix, can be the same as A
          //
          // Note: This is just calling an Eigen one-liner.

    parula(...) method of builtins.PyCapsule instance
        parula(*args, **kwargs)
        Overloaded function.

        1. parula(f: float) -> Tuple[float, float, float]

        // PARULA like MATLAB's parula
          //
          // Inputs:
          //   m  number of colors
          // Outputs:
          //   J  m by list of RGB colors between 0 and 1
          //
          // Wrapper for directly computing [r,g,b] values for a given factor f between
          // 0 and 1
          //
          // Inputs:
          //   f  factor determining color value as if 0 was min and 1 was max
          // Outputs:
          //   r  red value
          //   g  green value
          //   b  blue value

        2. parula(f: float, r: float, g: float, b: float) -> None

        // PARULA like MATLAB's parula
          //
          // Inputs:
          //   m  number of colors
          // Outputs:
          //   J  m by list of RGB colors between 0 and 1
          //
          // Wrapper for directly computing [r,g,b] values for a given factor f between
          // 0 and 1
          //
          // Inputs:
          //   f  factor determining color value as if 0 was min and 1 was max
          // Outputs:
          //   r  red value
          //   g  green value
          //   b  blue value

        3. parula(Z: pyigl.eigen.MatrixXd, normalize: bool, C: pyigl.eigen.MatrixXd) -> None

        // PARULA like MATLAB's parula
          //
          // Inputs:
          //   m  number of colors
          // Outputs:
          //   J  m by list of RGB colors between 0 and 1
          //
          // Wrapper for directly computing [r,g,b] values for a given factor f between
          // 0 and 1
          //
          // Inputs:
          //   f  factor determining color value as if 0 was min and 1 was max
          // Outputs:
          //   r  red value
          //   g  green value
          //   b  blue value

        4. parula(Z: pyigl.eigen.MatrixXd, min_Z: float, max_Z: float, C: pyigl.eigen.MatrixXd) -> None

        // PARULA like MATLAB's parula
          //
          // Inputs:
          //   m  number of colors
          // Outputs:
          //   J  m by list of RGB colors between 0 and 1
          //
          // Wrapper for directly computing [r,g,b] values for a given factor f between
          // 0 and 1
          //
          // Inputs:
          //   f  factor determining color value as if 0 was min and 1 was max
          // Outputs:
          //   r  red value
          //   g  green value
          //   b  blue value

    per_corner_normals(...) method of builtins.PyCapsule instance
        per_corner_normals(*args, **kwargs)
        Overloaded function.

        1. per_corner_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, corner_threshold: float, CN: pyigl.eigen.MatrixXd) -> None

        // Compute vertex normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigne Matrix of face (triangle) indices
          //   corner_threshold  threshold in degrees on sharp angles
          // Output:
          //   CN  #F*3 by 3 eigen Matrix of mesh vertex 3D normals, where the normal
          //     for corner F(i,j) is at CN(i*3+j,:)

        2. per_corner_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, FN: pyigl.eigen.MatrixXd, corner_threshold: float, CN: pyigl.eigen.MatrixXd) -> None

        // Compute vertex normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigne Matrix of face (triangle) indices
          //   corner_threshold  threshold in degrees on sharp angles
          // Output:
          //   CN  #F*3 by 3 eigen Matrix of mesh vertex 3D normals, where the normal
          //     for corner F(i,j) is at CN(i*3+j,:)

        3. per_corner_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, FN: pyigl.eigen.MatrixXd, corner_threshold: float, VF: pyigl.VectorVectorInt, CN: pyigl.eigen.MatrixXd) -> None

        // Compute vertex normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigne Matrix of face (triangle) indices
          //   corner_threshold  threshold in degrees on sharp angles
          // Output:
          //   CN  #F*3 by 3 eigen Matrix of mesh vertex 3D normals, where the normal
          //     for corner F(i,j) is at CN(i*3+j,:)

    per_edge_normals(...) method of builtins.PyCapsule instance
        per_edge_normals(*args, **kwargs)
        Overloaded function.

        1. per_edge_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, weight: pyigl.PerEdgeNormalsWeightingType, FN: pyigl.eigen.MatrixXd, N: pyigl.eigen.MatrixXd, E: pyigl.eigen.MatrixXi, EMAP: pyigl.eigen.MatrixXi) -> None

        // Compute face normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigen Matrix of face (triangle) indices
          //   weight  weighting type
          //   FN  #F by 3 matrix of 3D face normals per face
          // Output:
          //   N  #2 by 3 matrix of mesh edge 3D normals per row
          //   E  #E by 2 matrix of edge indices per row
          //   EMAP  #E by 1 matrix of indices from all edges to E
          //

        2. per_edge_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, weight: pyigl.PerEdgeNormalsWeightingType, N: pyigl.eigen.MatrixXd, E: pyigl.eigen.MatrixXi, EMAP: pyigl.eigen.MatrixXi) -> None

        // Compute face normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigen Matrix of face (triangle) indices
          //   weight  weighting type
          //   FN  #F by 3 matrix of 3D face normals per face
          // Output:
          //   N  #2 by 3 matrix of mesh edge 3D normals per row
          //   E  #E by 2 matrix of edge indices per row
          //   EMAP  #E by 1 matrix of indices from all edges to E
          //

        3. per_edge_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, N: pyigl.eigen.MatrixXd, E: pyigl.eigen.MatrixXi, EMAP: pyigl.eigen.MatrixXi) -> None

        // Compute face normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigen Matrix of face (triangle) indices
          //   weight  weighting type
          //   FN  #F by 3 matrix of 3D face normals per face
          // Output:
          //   N  #2 by 3 matrix of mesh edge 3D normals per row
          //   E  #E by 2 matrix of edge indices per row
          //   EMAP  #E by 1 matrix of indices from all edges to E
          //

    per_face_normals(...) method of builtins.PyCapsule instance
        per_face_normals(*args, **kwargs)
        Overloaded function.

        1. per_face_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, Z: pyigl.eigen.MatrixXd, N: pyigl.eigen.MatrixXd) -> None

        // Compute face normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigen Matrix of face (triangle) indices
          //   Z  3 vector normal given to faces with degenerate normal.
          // Output:
          //   N  #F by 3 eigen Matrix of mesh face (triangle) 3D normals
          //
          // Example:
          //   // Give degenerate faces (1/3,1/3,1/3)^0.5
          //   per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);

        2. per_face_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, N: pyigl.eigen.MatrixXd) -> None

        // Compute face normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigen Matrix of face (triangle) indices
          //   Z  3 vector normal given to faces with degenerate normal.
          // Output:
          //   N  #F by 3 eigen Matrix of mesh face (triangle) 3D normals
          //
          // Example:
          //   // Give degenerate faces (1/3,1/3,1/3)^0.5
          //   per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);

    per_face_normals_stable(...) method of builtins.PyCapsule instance
        per_face_normals_stable(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, N: pyigl.eigen.MatrixXd) -> None

        // Compute face normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigen Matrix of face (triangle) indices
          //   Z  3 vector normal given to faces with degenerate normal.
          // Output:
          //   N  #F by 3 eigen Matrix of mesh face (triangle) 3D normals
          //
          // Example:
          //   // Give degenerate faces (1/3,1/3,1/3)^0.5
          //   per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);

    per_vertex_normals(...) method of builtins.PyCapsule instance
        per_vertex_normals(*args, **kwargs)
        Overloaded function.

        1. per_vertex_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, weighting: pyigl.PerVertexNormalsWeightingType, N: pyigl.eigen.MatrixXd) -> None

        // Compute vertex normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigne Matrix of face (triangle) indices
          //   weighting  Weighting type
          // Output:
          //   N  #V by 3 eigen Matrix of mesh vertex 3D normals

        2. per_vertex_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, N: pyigl.eigen.MatrixXd) -> None

        // Compute vertex normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigne Matrix of face (triangle) indices
          //   weighting  Weighting type
          // Output:
          //   N  #V by 3 eigen Matrix of mesh vertex 3D normals

        3. per_vertex_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, weighting: pyigl.PerVertexNormalsWeightingType, FN: pyigl.eigen.MatrixXd, N: pyigl.eigen.MatrixXd) -> None

        // Compute vertex normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigne Matrix of face (triangle) indices
          //   weighting  Weighting type
          // Output:
          //   N  #V by 3 eigen Matrix of mesh vertex 3D normals

        4. per_vertex_normals(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, FN: pyigl.eigen.MatrixXd, N: pyigl.eigen.MatrixXd) -> None

        // Compute vertex normals via vertex position list, face list
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 3 eigne Matrix of face (triangle) indices
          //   weighting  Weighting type
          // Output:
          //   N  #V by 3 eigen Matrix of mesh vertex 3D normals

    planarize_quad_mesh(...) method of builtins.PyCapsule instance
        planarize_quad_mesh(Vin: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, maxIter: int, threshold: float, Vout: pyigl.eigen.MatrixXd) -> None

        // Inputs:
          //   Vin        #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F          #F by 4 eigen Matrix of face (quad) indices
          //   maxIter    maximum numbers of iterations
          //   threshold  minimum allowed threshold for non-planarity
          // Output:
          //   Vout       #V by 3 eigen Matrix of planar mesh vertex 3D positions
          //

    point_mesh_squared_distance(...) method of builtins.PyCapsule instance
        point_mesh_squared_distance(P: pyigl.eigen.MatrixXd, V: pyigl.eigen.MatrixXd, Ele: pyigl.eigen.MatrixXi, sqrD: pyigl.eigen.MatrixXd, I: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXd) -> None

        // Compute distances from a set of points P to a triangle mesh (V,F)
          //
          // Inputs:
          //   P  #P by 3 list of query point positions
          //   V  #V by 3 list of vertex positions
          //   Ele  #Ele by (3|2|1) list of (triangle|edge|point) indices
          // Outputs:
          //   sqrD  #P list of smallest squared distances
          //   I  #P list of primitive indices corresponding to smallest distances
          //   C  #P by 3 list of closest points
          //
          // Known bugs: This only computes distances to given primitivess. So
          // unreferenced vertices are ignored. However, degenerate primitives are
          // handled correctly: triangle [1 2 2] is treated as a segment [1 2], and
          // triangle [1 1 1] is treated as a point. So one _could_ add extra
          // combinatorially degenerate rows to Ele for all unreferenced vertices to
          // also get distances to points.

    polar_svd(...) method of builtins.PyCapsule instance
        polar_svd(*args, **kwargs)
        Overloaded function.

        1. polar_svd(A: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXd, T: pyigl.eigen.MatrixXd, U: pyigl.eigen.MatrixXd, S: pyigl.eigen.MatrixXd, V: pyigl.eigen.MatrixXd) -> None

        // Computes the polar decomposition (R,T) of a matrix A using SVD singular
          // value decomposition
          //
          // Inputs:
          //   A  3 by 3 matrix to be decomposed
          // Outputs:
          //   R  3 by 3 rotation matrix part of decomposition (**always rotataion**)
          //   T  3 by 3 stretch matrix part of decomposition
          //   U  3 by 3 left-singular vectors
          //   S  3 by 1 singular values
          //   V  3 by 3 right-singular vectors
          //
          //

        2. polar_svd(A: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXd, T: pyigl.eigen.MatrixXd) -> None

        // Computes the polar decomposition (R,T) of a matrix A using SVD singular
          // value decomposition
          //
          // Inputs:
          //   A  3 by 3 matrix to be decomposed
          // Outputs:
          //   R  3 by 3 rotation matrix part of decomposition (**always rotataion**)
          //   T  3 by 3 stretch matrix part of decomposition
          //   U  3 by 3 left-singular vectors
          //   S  3 by 1 singular values
          //   V  3 by 3 right-singular vectors
          //
          //

    principal_curvature(...) method of builtins.PyCapsule instance
        principal_curvature(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, PD1: pyigl.eigen.MatrixXd, PD2: pyigl.eigen.MatrixXd, PV1: pyigl.eigen.MatrixXd, PV2: pyigl.eigen.MatrixXd, radius: int = 5, useKring: bool = True) -> None

        // Compute the principal curvature directions and magnitude of the given triangle mesh
          //   DerivedV derived from vertex positions matrix type: i.e. MatrixXd
          //   DerivedF derived from face indices matrix type: i.e. MatrixXi
          // Inputs:
          //   V       eigen matrix #V by 3
          //   F       #F by 3 list of mesh faces (must be triangles)
          //   radius  controls the size of the neighbourhood used, 1 = average edge length
          //
          // Outputs:
          //   PD1 #V by 3 maximal curvature direction for each vertex.
          //   PD2 #V by 3 minimal curvature direction for each vertex.
          //   PV1 #V by 1 maximal curvature value for each vertex.
          //   PV2 #V by 1 minimal curvature value for each vertex.
          //
          // See also: average_onto_faces, average_onto_vertices
          //
          // This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo.
          // The algorithm is based on:
          // Efficient Multi-scale Curvature and Crease Estimation
          // Daniele Panozzo, Enrico Puppo, Luigi Rocca
          // GraVisMa, 2010

    quad_planarity(...) method of builtins.PyCapsule instance
        quad_planarity(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, P: pyigl.eigen.MatrixXd) -> None

        // Compute planarity of the faces of a quad mesh
          // Inputs:
          //   V  #V by 3 eigen Matrix of mesh vertex 3D positions
          //   F  #F by 4 eigen Matrix of face (quad) indices
          // Output:
          //   P  #F by 1 eigen Matrix of mesh face (quad) planarities
          //

    randperm(...) method of builtins.PyCapsule instance
        randperm(n: int, I: pyigl.eigen.MatrixXi) -> None

        // Like matlab's randperm(n) but minus 1
          //
          // Inputs:
          //   n  number of elements
          // Outputs:
          //   I  n list of rand permutation of 0:n-1

    readDMAT(...) method of builtins.PyCapsule instance
        readDMAT(str: str, W: pyigl.eigen.MatrixXd) -> bool

        See readDMAT for the documentation.

    readMESH(...) method of builtins.PyCapsule instance
        readMESH(*args, **kwargs)
        Overloaded function.

        1. readMESH(mesh_file_name: str, V: pyigl.eigen.MatrixXd, T: pyigl.eigen.MatrixXi, F: pyigl.eigen.MatrixXi) -> bool

        // load a tetrahedral volume mesh from a .mesh file
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be read as double and cast
          //     to Scalar)
          //   Index  type for indices (will be read as int and cast to Index)
          // Input:
          //   mesh_file_name  path of .mesh file
          // Outputs:
          //   V  double matrix of vertex positions  #V by 3
          //   T  #T list of tet indices into vertex positions
          //   F  #F list of face indices into vertex positions
          //
          // Known bugs: Holes and regions are not supported

        2. readMESH(mesh_file_name: str, V: List[List[float]], T: pyigl.VectorVectorInt, F: pyigl.VectorVectorInt) -> bool

        // load a tetrahedral volume mesh from a .mesh file
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be read as double and cast
          //     to Scalar)
          //   Index  type for indices (will be read as int and cast to Index)
          // Input:
          //   mesh_file_name  path of .mesh file
          // Outputs:
          //   V  double matrix of vertex positions  #V by 3
          //   T  #T list of tet indices into vertex positions
          //   F  #F list of face indices into vertex positions
          //
          // Known bugs: Holes and regions are not supported

    readOBJ(...) method of builtins.PyCapsule instance
        readOBJ(*args, **kwargs)
        Overloaded function.

        1. readOBJ(str: str, V: pyigl.eigen.MatrixXd, TC: pyigl.eigen.MatrixXd, CN: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, FTC: pyigl.eigen.MatrixXi, FN: pyigl.eigen.MatrixXi) -> bool

        // Read a mesh from an ascii obj file, filling in vertex positions, normals
          // and texture coordinates. Mesh may have faces of any number of degree
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be read as double and cast
          //     to Scalar)
          //   Index  type for indices (will be read as int and cast to Index)
          // Inputs:
          //  str  path to .obj file
          // Outputs:
          //   V  double matrix of vertex positions  #V by 3
          //   TC  double matrix of texture coordinats #TC by 2
          //   N  double matrix of corner normals #N by 3
          //   F  #F list of face indices into vertex positions
          //   FTC  #F list of face indices into vertex texture coordinates
          //   FN  #F list of face indices into vertex normals
          // Returns true on success, false on errors

        2. readOBJ(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi) -> bool

        // Read a mesh from an ascii obj file, filling in vertex positions, normals
          // and texture coordinates. Mesh may have faces of any number of degree
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be read as double and cast
          //     to Scalar)
          //   Index  type for indices (will be read as int and cast to Index)
          // Inputs:
          //  str  path to .obj file
          // Outputs:
          //   V  double matrix of vertex positions  #V by 3
          //   TC  double matrix of texture coordinats #TC by 2
          //   N  double matrix of corner normals #N by 3
          //   F  #F list of face indices into vertex positions
          //   FTC  #F list of face indices into vertex texture coordinates
          //   FN  #F list of face indices into vertex normals
          // Returns true on success, false on errors

    readOFF(...) method of builtins.PyCapsule instance
        readOFF(*args, **kwargs)
        Overloaded function.

        1. readOFF(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi) -> bool

        // Read a mesh from an ascii OFF file, filling in vertex positions, normals
          // and texture coordinates. Mesh may have faces of any number of degree
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be read as double and cast
          //     to Scalar)
          //   Index  type for indices (will be read as int and cast to Index)
          // Inputs:
          //  str  path to .obj file
          // Outputs:
          //   V  double matrix of vertex positions  #V by 3
          //   F  #F list of face indices into vertex positions
          //   N  list of vertex normals #V by 3
          //   C  list of rgb color values per vertex #V by 3
          // Returns true on success, false on errors

        2. readOFF(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, N: pyigl.eigen.MatrixXd) -> bool

        // Read a mesh from an ascii OFF file, filling in vertex positions, normals
          // and texture coordinates. Mesh may have faces of any number of degree
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be read as double and cast
          //     to Scalar)
          //   Index  type for indices (will be read as int and cast to Index)
          // Inputs:
          //  str  path to .obj file
          // Outputs:
          //   V  double matrix of vertex positions  #V by 3
          //   F  #F list of face indices into vertex positions
          //   N  list of vertex normals #V by 3
          //   C  list of rgb color values per vertex #V by 3
          // Returns true on success, false on errors

    readPLY(...) method of builtins.PyCapsule instance
        readPLY(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, N: pyigl.eigen.MatrixXd, UV: pyigl.eigen.MatrixXd) -> bool

        // Read a mesh from an ascii ply file, filling in vertex positions,
          // mesh indices, normals and texture coordinates
          // Inputs:
          //  str path to .obj file
          // Outputs:
          //   V  double matrix of vertex positions  #V by 3
          //   F  #F list of face indices into vertex positions
          //   N  double matrix of corner normals #N by 3
          //   UV #V by 2 texture coordinates
          // Returns true on success, false on errors

    readTGF(...) method of builtins.PyCapsule instance
        readTGF(*args, **kwargs)
        Overloaded function.

        1. readTGF(tgf_filename: str, C: pyigl.eigen.MatrixXd, E: pyigl.eigen.MatrixXi, P: pyigl.eigen.MatrixXi, BE: pyigl.eigen.MatrixXi, CE: pyigl.eigen.MatrixXi, PE: pyigl.eigen.MatrixXi) -> bool

        // READTGF
          //
          // [V,E,P,BE,CE,PE] = readTGF(filename)
          //
          // Read a graph from a .tgf file
          //
          // Input:
          //  filename  .tgf file name
          // Output:
          //  V  # vertices by 3 list of vertex positions
          //  E  # edges by 2 list of edge indices
          //  P  # point-handles list of point handle indices
          //  BE # bone-edges by 2 list of bone-edge indices
          //  CE # cage-edges by 2 list of cage-edge indices
          //  PE # pseudo-edges by 2 list of pseudo-edge indices
          //
          // Assumes that graph vertices are 3 dimensional

        2. readTGF(tgf_filename: str, C: pyigl.eigen.MatrixXd, E: pyigl.eigen.MatrixXi) -> bool

        // READTGF
          //
          // [V,E,P,BE,CE,PE] = readTGF(filename)
          //
          // Read a graph from a .tgf file
          //
          // Input:
          //  filename  .tgf file name
          // Output:
          //  V  # vertices by 3 list of vertex positions
          //  E  # edges by 2 list of edge indices
          //  P  # point-handles list of point handle indices
          //  BE # bone-edges by 2 list of bone-edge indices
          //  CE # cage-edges by 2 list of cage-edge indices
          //  PE # pseudo-edges by 2 list of pseudo-edge indices
          //
          // Assumes that graph vertices are 3 dimensional

    read_triangle_mesh(...) method of builtins.PyCapsule instance
        read_triangle_mesh(*args, **kwargs)
        Overloaded function.

        1. read_triangle_mesh(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi) -> bool

        // read mesh from an ascii file with automatic detection of file format.
          // supported: obj, off, stl, wrl, ply, mesh)
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be read as double and cast
          //     to Scalar)
          //   Index  type for indices (will be read as int and cast to Index)
          // Inputs:
          //   str  path to file
          // Outputs:
          //   V  eigen double matrix #V by 3
          //   F  eigen int matrix #F by 3
          // Returns true iff success

        2. read_triangle_mesh(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, dir: str, base: str, ext: str, name: str) -> bool

        // read mesh from an ascii file with automatic detection of file format.
          // supported: obj, off, stl, wrl, ply, mesh)
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be read as double and cast
          //     to Scalar)
          //   Index  type for indices (will be read as int and cast to Index)
          // Inputs:
          //   str  path to file
          // Outputs:
          //   V  eigen double matrix #V by 3
          //   F  eigen int matrix #F by 3
          // Returns true iff success

        3. read_triangle_mesh(str: str, V: List[List[float]], F: pyigl.VectorVectorInt) -> bool

        // read mesh from an ascii file with automatic detection of file format.
          // supported: obj, off, stl, wrl, ply, mesh)
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be read as double and cast
          //     to Scalar)
          //   Index  type for indices (will be read as int and cast to Index)
          // Inputs:
          //   str  path to file
          // Outputs:
          //   V  eigen double matrix #V by 3
          //   F  eigen int matrix #F by 3
          // Returns true iff success

    remove_duplicate_vertices(...) method of builtins.PyCapsule instance
        remove_duplicate_vertices(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, epsilon: float, SV: pyigl.eigen.MatrixXd, SVI: pyigl.eigen.MatrixXi, SVJ: pyigl.eigen.MatrixXi, SF: pyigl.eigen.MatrixXi) -> None

        // REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness
          // tolerance (epsilon)
          //
          // Inputs:
          //   V  #V by dim list of vertex positions
          //   epsilon  uniqueness tolerance (significant digit), can probably think of
          //     this as a tolerance on L1 distance
          // Outputs:
          //   SV  #SV by dim new list of vertex positions
          //   SVI #V by 1 list of indices so SV = V(SVI,:)
          //   SVJ #SV by 1 list of indices so V = SV(SVJ,:)
          //
          // Example:
          //   % Mesh in (V,F)
          //   [SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7);
          //   % remap faces
          //   SF = SVJ(F);
          //

    rotate_vectors(...) method of builtins.PyCapsule instance
        rotate_vectors(V: pyigl.eigen.MatrixXd, A: pyigl.eigen.MatrixXd, B1: pyigl.eigen.MatrixXd, B2: pyigl.eigen.MatrixXd) -> pyigl.eigen.MatrixXd

        // Rotate the vectors V by A radiants on the tangent plane spanned by B1 and
          // B2
          //
          // Inputs:
          //   V     #V by 3 eigen Matrix of vectors
          //   A     #V eigen vector of rotation angles or a single angle to be applied
          //     to all vectors
          //   B1    #V by 3 eigen Matrix of base vector 1
          //   B2    #V by 3 eigen Matrix of base vector 2
          //
          // Output:
          //   Returns the rotated vectors
          //

    seam_edges(...) method of builtins.PyCapsule instance
        seam_edges(V: pyigl.eigen.MatrixXd, TC: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, FTC: pyigl.eigen.MatrixXi, seams: pyigl.eigen.MatrixXi, boundaries: pyigl.eigen.MatrixXi, foldovers: pyigl.eigen.MatrixXi) -> None

        // Finds all UV-space boundaries of a mesh.
          //
          // Inputs:
          //   V  #V by dim list of positions of the input mesh.
          //   TC  #TC by 2 list of 2D texture coordinates of the input mesh
          //   F  #F by 3 list of triange indices into V representing a
          //     manifold-with-boundary triangle mesh
          //   FTC  #F by 3 list of indices into TC for each corner
          // Outputs:
          //   seams  Edges where the forwards and backwards directions have different
          //     texture coordinates, as a #seams-by-4 matrix of indices. Each row is
          //     organized as [ forward_face_index, forward_face_vertex_index,
          //     backwards_face_index, backwards_face_vertex_index ] such that one side
          //     of the seam is the edge:
          //         F[ seams( i, 0 ), seams( i, 1 ) ], F[ seams( i, 0 ), (seams( i, 1 ) + 1) % 3 ]
          //     and the other side is the edge:
          //         F[ seams( i, 2 ), seams( i, 3 ) ], F[ seams( i, 2 ), (seams( i, 3 ) + 1) % 3 ]
          //   boundaries  Edges with only one incident triangle, as a #boundaries-by-2
          //     matrix of indices. Each row is organized as
          //         [ face_index, face_vertex_index ]
          //     such that the edge is:
          //         F[ boundaries( i, 0 ), boundaries( i, 1 ) ], F[ boundaries( i, 0 ), (boundaries( i, 1 ) + 1) % 3 ]
          //   foldovers  Edges where the two incident triangles fold over each other
          //     in UV-space, as a #foldovers-by-4 matrix of indices.
          //     Each row is organized as [ forward_face_index, forward_face_vertex_index,
          //     backwards_face_index, backwards_face_vertex_index ]
          //     such that one side of the foldover is the edge:
          //       F[ foldovers( i, 0 ), foldovers( i, 1 ) ], F[ foldovers( i, 0 ), (foldovers( i, 1 ) + 1) % 3 ]
          //     and the other side is the edge:
          //       F[ foldovers( i, 2 ), foldovers( i, 3 ) ], F[ foldovers( i, 2 ), (foldovers( i, 3 ) + 1) % 3 ]

    setdiff(...) method of builtins.PyCapsule instance
        setdiff(A: pyigl.eigen.MatrixXi, B: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, IA: pyigl.eigen.MatrixXi) -> None

        // Set difference of elements of matrices
          //
          // Inputs:
          //   A  m-long vector of indices
          //   B  n-long vector of indices
          // Outputs:
          //   C  (k<=m)-long vector of unique elements appearing in A but not in B
          //   IA  (k<=m)-long list of indices into A so that C = A(IA)
          //

    shape_diameter_function(...) method of builtins.PyCapsule instance
        shape_diameter_function(*args, **kwargs)
        Overloaded function.

        1. shape_diameter_function(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, P: pyigl.eigen.MatrixXd, N: pyigl.eigen.MatrixXd, num_samples: int, S: pyigl.eigen.MatrixXd) -> None

        // Compute shape diamater function per given point. In the parlence of the
          // paper "Consistent Mesh Partitioning and Skeletonisation using the Shape
          // Diameter Function" [Shapiro et al. 2008], this implementation uses a 180
          // cone and a _uniform_ average (_not_ a average weighted by inverse angles).
          //
          // Inputs:
          //    shoot_ray  function handle that outputs hits of a given ray against a
          //      mesh (embedded in function handles as captured variable/data)
          //    P  #P by 3 list of origin points
          //    N  #P by 3 list of origin normals
          // Outputs:
          //    S  #P list of shape diamater function values between bounding box
          //    diagonal (perfect sphere) and 0 (perfect needle hook)
          //

        2. shape_diameter_function(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, per_face: bool, num_samples: int, S: pyigl.eigen.MatrixXd) -> None

        // Compute shape diamater function per given point. In the parlence of the
          // paper "Consistent Mesh Partitioning and Skeletonisation using the Shape
          // Diameter Function" [Shapiro et al. 2008], this implementation uses a 180
          // cone and a _uniform_ average (_not_ a average weighted by inverse angles).
          //
          // Inputs:
          //    shoot_ray  function handle that outputs hits of a given ray against a
          //      mesh (embedded in function handles as captured variable/data)
          //    P  #P by 3 list of origin points
          //    N  #P by 3 list of origin normals
          // Outputs:
          //    S  #P list of shape diamater function values between bounding box
          //    diagonal (perfect sphere) and 0 (perfect needle hook)
          //

    signed_distance(...) method of builtins.PyCapsule instance
        signed_distance(P: pyigl.eigen.MatrixXd, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, sign_type: pyigl.SignedDistanceType, S: pyigl.eigen.MatrixXd, I: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXd, N: pyigl.eigen.MatrixXd) -> None

        // Computes signed distance to a mesh
          //
          // Inputs:
          //   P  #P by 3 list of query point positions
          //   V  #V by 3 list of vertex positions
          //   F  #F by ss list of triangle indices, ss should be 3 unless sign_type ==
          //     SIGNED_DISTANCE_TYPE_UNSIGNED
          //   sign_type  method for computing distance _sign_ S
          // Outputs:
          //   S  #P list of smallest signed distances
          //   I  #P list of facet indices corresponding to smallest distances
          //   C  #P by 3 list of closest points
          //   N  #P by 3 list of closest normals (only set if
          //     sign_type=SIGNED_DISTANCE_TYPE_PSEUDONORMAL)
          //
          // Known bugs: This only computes distances to triangles. So unreferenced
          // vertices and degenerate triangles are ignored.

    signed_distance_pseudonormal(...) method of builtins.PyCapsule instance
        signed_distance_pseudonormal(P: pyigl.eigen.MatrixXd, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, tree: pyigl.AABB, FN: pyigl.eigen.MatrixXd, VN: pyigl.eigen.MatrixXd, EN: pyigl.eigen.MatrixXd, EMAP: pyigl.eigen.MatrixXi, S: pyigl.eigen.MatrixXd, I: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXd, N: pyigl.eigen.MatrixXd) -> None

        // Computes signed distance to mesh
          //
          // Inputs:
          //   tree  AABB acceleration tree (see AABB.h)
          //   F  #F by 3 list of triangle indices
          //   FN  #F by 3 list of triangle normals
          //   VN  #V by 3 list of vertex normals (ANGLE WEIGHTING)
          //   EN  #E by 3 list of edge normals (UNIFORM WEIGHTING)
          //   EMAP  #F*3 mapping edges in F to E
          //   q  Query point
          // Returns signed distance to mesh
          //

    slice(...) method of builtins.PyCapsule instance
        slice(*args, **kwargs)
        Overloaded function.

        1. slice(X: pyigl.eigen.SparseMatrixd, R: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, Y: pyigl.eigen.SparseMatrixd) -> None

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        2. slice(X: pyigl.eigen.SparseMatrixd, R: pyigl.eigen.MatrixXi, dim: int, Y: pyigl.eigen.SparseMatrixd) -> None

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        3. slice(X: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXd) -> None

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        4. slice(X: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXi, dim: int, Y: pyigl.eigen.MatrixXd) -> None

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        5. slice(X: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXd) -> None

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        6. slice(X: pyigl.eigen.MatrixXd, A: pyigl.eigen.MatrixXi) -> pyigl.eigen.MatrixXd

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        7. slice(X: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXi, dim: int) -> pyigl.eigen.MatrixXd

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        8. slice(X: pyigl.eigen.SparseMatrixi, R: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, Y: pyigl.eigen.SparseMatrixi) -> None

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        9. slice(X: pyigl.eigen.SparseMatrixi, R: pyigl.eigen.MatrixXi, dim: int, Y: pyigl.eigen.SparseMatrixi) -> None

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        10. slice(X: pyigl.eigen.MatrixXi, R: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXi) -> None

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        11. slice(X: pyigl.eigen.MatrixXi, R: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXi) -> None

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        12. slice(X: pyigl.eigen.MatrixXi, R: pyigl.eigen.MatrixXi) -> pyigl.eigen.MatrixXi

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

        13. slice(X: pyigl.eigen.MatrixXi, R: pyigl.eigen.MatrixXi, dim: int) -> pyigl.eigen.MatrixXi

        // Act like the matlab X(row_indices,col_indices) operator, where
          // row_indices, col_indices are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  list of row indices
          //   C  list of column indices
          // Output:
          //   Y  #R by #C matrix
          //
          // See also: slice_mask

    slice_into(...) method of builtins.PyCapsule instance
        slice_into(*args, **kwargs)
        Overloaded function.

        1. slice_into(X: pyigl.eigen.SparseMatrixd, R: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, Y: pyigl.eigen.SparseMatrixd) -> None

        // Act like the matlab Y(row_indices,col_indices) = X
          //
          // Inputs:
          //   X  xm by xn rhs matrix
          //   R  list of row indices
          //   C  list of column indices
          //   Y  ym by yn lhs matrix
          // Output:
          //   Y  ym by yn lhs matrix, same as input but Y(R,C) = X

        2. slice_into(X: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXd) -> None

        // Act like the matlab Y(row_indices,col_indices) = X
          //
          // Inputs:
          //   X  xm by xn rhs matrix
          //   R  list of row indices
          //   C  list of column indices
          //   Y  ym by yn lhs matrix
          // Output:
          //   Y  ym by yn lhs matrix, same as input but Y(R,C) = X

        3. slice_into(X: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXi, dim: int, Y: pyigl.eigen.MatrixXd) -> None

        // Act like the matlab Y(row_indices,col_indices) = X
          //
          // Inputs:
          //   X  xm by xn rhs matrix
          //   R  list of row indices
          //   C  list of column indices
          //   Y  ym by yn lhs matrix
          // Output:
          //   Y  ym by yn lhs matrix, same as input but Y(R,C) = X

        4. slice_into(X: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXd) -> None

        // Act like the matlab Y(row_indices,col_indices) = X
          //
          // Inputs:
          //   X  xm by xn rhs matrix
          //   R  list of row indices
          //   C  list of column indices
          //   Y  ym by yn lhs matrix
          // Output:
          //   Y  ym by yn lhs matrix, same as input but Y(R,C) = X

        5. slice_into(X: pyigl.eigen.SparseMatrixi, R: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, Y: pyigl.eigen.SparseMatrixi) -> None

        // Act like the matlab Y(row_indices,col_indices) = X
          //
          // Inputs:
          //   X  xm by xn rhs matrix
          //   R  list of row indices
          //   C  list of column indices
          //   Y  ym by yn lhs matrix
          // Output:
          //   Y  ym by yn lhs matrix, same as input but Y(R,C) = X

        6. slice_into(X: pyigl.eigen.MatrixXi, R: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXi) -> None

        // Act like the matlab Y(row_indices,col_indices) = X
          //
          // Inputs:
          //   X  xm by xn rhs matrix
          //   R  list of row indices
          //   C  list of column indices
          //   Y  ym by yn lhs matrix
          // Output:
          //   Y  ym by yn lhs matrix, same as input but Y(R,C) = X

        7. slice_into(X: pyigl.eigen.MatrixXi, R: pyigl.eigen.MatrixXi, dim: int, Y: pyigl.eigen.MatrixXi) -> None

        // Act like the matlab Y(row_indices,col_indices) = X
          //
          // Inputs:
          //   X  xm by xn rhs matrix
          //   R  list of row indices
          //   C  list of column indices
          //   Y  ym by yn lhs matrix
          // Output:
          //   Y  ym by yn lhs matrix, same as input but Y(R,C) = X

        8. slice_into(X: pyigl.eigen.MatrixXi, R: pyigl.eigen.MatrixXi, Y: pyigl.eigen.MatrixXi) -> None

        // Act like the matlab Y(row_indices,col_indices) = X
          //
          // Inputs:
          //   X  xm by xn rhs matrix
          //   R  list of row indices
          //   C  list of column indices
          //   Y  ym by yn lhs matrix
          // Output:
          //   Y  ym by yn lhs matrix, same as input but Y(R,C) = X

    slice_mask(...) method of builtins.PyCapsule instance
        slice_mask(*args, **kwargs)
        Overloaded function.

        1. slice_mask(X: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXb, C: pyigl.eigen.MatrixXb, Y: pyigl.eigen.MatrixXd) -> None

        // Act like the matlab X(row_mask,col_mask) operator, where
          // row_mask, col_mask are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  m list of row bools
          //   C  n list of column bools
          // Output:
          //   Y  #trues-in-R by #trues-in-C matrix
          //
          // See also: slice_mask

        2. slice_mask(X: pyigl.eigen.MatrixXd, R: pyigl.eigen.MatrixXb, dim: int, Y: pyigl.eigen.MatrixXd) -> None

        // Act like the matlab X(row_mask,col_mask) operator, where
          // row_mask, col_mask are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  m list of row bools
          //   C  n list of column bools
          // Output:
          //   Y  #trues-in-R by #trues-in-C matrix
          //
          // See also: slice_mask

        3. slice_mask(X: pyigl.eigen.MatrixXi, R: pyigl.eigen.MatrixXb, C: pyigl.eigen.MatrixXb, Y: pyigl.eigen.MatrixXi) -> None

        // Act like the matlab X(row_mask,col_mask) operator, where
          // row_mask, col_mask are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  m list of row bools
          //   C  n list of column bools
          // Output:
          //   Y  #trues-in-R by #trues-in-C matrix
          //
          // See also: slice_mask

        4. slice_mask(X: pyigl.eigen.MatrixXi, R: pyigl.eigen.MatrixXb, dim: int, Y: pyigl.eigen.MatrixXi) -> None

        // Act like the matlab X(row_mask,col_mask) operator, where
          // row_mask, col_mask are non-negative integer indices.
          //
          // Inputs:
          //   X  m by n matrix
          //   R  m list of row bools
          //   C  n list of column bools
          // Output:
          //   Y  #trues-in-R by #trues-in-C matrix
          //
          // See also: slice_mask

    sortrows(...) method of builtins.PyCapsule instance
        sortrows(*args, **kwargs)
        Overloaded function.

        1. sortrows(X: pyigl.eigen.MatrixXd, ascending: bool, Y: pyigl.eigen.MatrixXd, I: pyigl.eigen.MatrixXi) -> None

        // Act like matlab's [Y,I] = sortrows(X)
          //
          // Templates:
          //   DerivedX derived scalar type, e.g. MatrixXi or MatrixXd
          //   DerivedI derived integer type, e.g. MatrixXi
          // Inputs:
          //   X  m by n matrix whose entries are to be sorted
          //   ascending  sort ascending (true, matlab default) or descending (false)
          // Outputs:
          //   Y  m by n matrix whose entries are sorted (**should not** be same
          //     reference as X)
          //   I  m list of indices so that
          //     Y = X(I,:);

        2. sortrows(X: pyigl.eigen.MatrixXi, ascending: bool, Y: pyigl.eigen.MatrixXi, I: pyigl.eigen.MatrixXi) -> None

        // Act like matlab's [Y,I] = sortrows(X)
          //
          // Templates:
          //   DerivedX derived scalar type, e.g. MatrixXi or MatrixXd
          //   DerivedI derived integer type, e.g. MatrixXi
          // Inputs:
          //   X  m by n matrix whose entries are to be sorted
          //   ascending  sort ascending (true, matlab default) or descending (false)
          // Outputs:
          //   Y  m by n matrix whose entries are sorted (**should not** be same
          //     reference as X)
          //   I  m list of indices so that
          //     Y = X(I,:);

    triangle_triangle_adjacency(...) method of builtins.PyCapsule instance
        triangle_triangle_adjacency(*args, **kwargs)
        Overloaded function.

        1. triangle_triangle_adjacency(F: pyigl.eigen.MatrixXi, TT: pyigl.eigen.MatrixXi, TTi: pyigl.eigen.MatrixXi) -> None

        // Constructs the triangle-triangle adjacency matrix for a given
          // mesh (V,F).
          //
          // Templates:
          //   Scalar derived type of eigen matrix for V (e.g. derived from
          //     MatrixXd)
          //   Index  derived type of eigen matrix for F (e.g. derived from
          //     MatrixXi)
          // Inputs:
          //   F  #F by simplex_size list of mesh faces (must be triangles)
          // Outputs:
          //   TT   #F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i
          //   TTi  #F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i
          // NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third [2,3].
          //       this convention is DIFFERENT from cotmatrix_entries.h
          // Known bug: this should not need to take V as input.

        2. triangle_triangle_adjacency(F: pyigl.eigen.MatrixXi, TT: pyigl.eigen.MatrixXi) -> None

        // Constructs the triangle-triangle adjacency matrix for a given
          // mesh (V,F).
          //
          // Templates:
          //   Scalar derived type of eigen matrix for V (e.g. derived from
          //     MatrixXd)
          //   Index  derived type of eigen matrix for F (e.g. derived from
          //     MatrixXi)
          // Inputs:
          //   F  #F by simplex_size list of mesh faces (must be triangles)
          // Outputs:
          //   TT   #F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i
          //   TTi  #F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i
          // NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third [2,3].
          //       this convention is DIFFERENT from cotmatrix_entries.h
          // Known bug: this should not need to take V as input.

    unique(...) method of builtins.PyCapsule instance
        unique(*args, **kwargs)
        Overloaded function.

        1. unique(A: pyigl.eigen.MatrixXd, C: pyigl.eigen.MatrixXd, IA: pyigl.eigen.MatrixXi, IC: pyigl.eigen.MatrixXi) -> None

        // Act like matlab's [C,IA,IC] = unique(X)
          //
          // Templates:
          //   T  comparable type T
          // Inputs:
          //   A  #A vector of type T
          // Outputs:
          //   C  #C vector of unique entries in A
          //   IA  #C index vector so that C = A(IA);
          //   IC  #A index vector so that A = C(IC);

        2. unique(A: pyigl.eigen.MatrixXd, C: pyigl.eigen.MatrixXd) -> None

        // Act like matlab's [C,IA,IC] = unique(X)
          //
          // Templates:
          //   T  comparable type T
          // Inputs:
          //   A  #A vector of type T
          // Outputs:
          //   C  #C vector of unique entries in A
          //   IA  #C index vector so that C = A(IA);
          //   IC  #A index vector so that A = C(IC);

        3. unique(A: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi, IA: pyigl.eigen.MatrixXi, IC: pyigl.eigen.MatrixXi) -> None

        // Act like matlab's [C,IA,IC] = unique(X)
          //
          // Templates:
          //   T  comparable type T
          // Inputs:
          //   A  #A vector of type T
          // Outputs:
          //   C  #C vector of unique entries in A
          //   IA  #C index vector so that C = A(IA);
          //   IC  #A index vector so that A = C(IC);

        4. unique(A: pyigl.eigen.MatrixXi, C: pyigl.eigen.MatrixXi) -> None

        // Act like matlab's [C,IA,IC] = unique(X)
          //
          // Templates:
          //   T  comparable type T
          // Inputs:
          //   A  #A vector of type T
          // Outputs:
          //   C  #C vector of unique entries in A
          //   IA  #C index vector so that C = A(IA);
          //   IC  #A index vector so that A = C(IC);

    unproject_onto_mesh(...) method of builtins.PyCapsule instance
        unproject_onto_mesh(pos: pyigl.eigen.MatrixXd, model: pyigl.eigen.MatrixXd, proj: pyigl.eigen.MatrixXd, viewport: pyigl.eigen.MatrixXd, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, fid: pyigl.eigen.MatrixXi, bc: pyigl.eigen.MatrixXd) -> bool

        // Unproject a screen location (using current opengl viewport, projection, and
          // model view) to a 3D position _onto_ a given mesh, if the ray through the
          // given screen location (x,y) _hits_ the mesh.
          //
          // Inputs:
          //    pos        screen space coordinates
          //    model      model matrix
          //    proj       projection matrix
          //    viewport   vieweport vector
          //    V   #V by 3 list of mesh vertex positions
          //    F   #F by 3 list of mesh triangle indices into V
          // Outputs:
          //    fid  id of the first face hit
          //    bc  barycentric coordinates of hit
          // Returns true if there's a hit

    upsample(...) method of builtins.PyCapsule instance
        upsample(*args, **kwargs)
        Overloaded function.

        1. upsample(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi) -> None

        // Subdivide without moving vertices: Given the triangle mesh [V, F],
          // where n_verts = V.rows(), computes newV and a sparse matrix S s.t.
          // [newV, newF] is the subdivided mesh where newV = S*V.
          //
          // Inputs:
          //   n_verts  an integer (number of mesh vertices)
          //   F  an m by 3 matrix of integers of triangle faces
          // Outputs:
          //   S  a sparse matrix (will become the subdivision matrix)
          //   newF  a matrix containing the new faces

        2. upsample(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, NV: pyigl.eigen.MatrixXd, NF: pyigl.eigen.MatrixXi) -> None

        // Subdivide without moving vertices: Given the triangle mesh [V, F],
          // where n_verts = V.rows(), computes newV and a sparse matrix S s.t.
          // [newV, newF] is the subdivided mesh where newV = S*V.
          //
          // Inputs:
          //   n_verts  an integer (number of mesh vertices)
          //   F  an m by 3 matrix of integers of triangle faces
          // Outputs:
          //   S  a sparse matrix (will become the subdivision matrix)
          //   newF  a matrix containing the new faces

    winding_number(...) method of builtins.PyCapsule instance
        winding_number(V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, O: pyigl.eigen.MatrixXd, W: pyigl.eigen.MatrixXd) -> None

        // WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron
          // described by points (vectors) V
          //
          // Templates:
          //   dim  dimension of input
          // Inputs:
          //  V  n by 3 list of vertex positions
          //  F  #F by 3 list of triangle indices, minimum index is 0
          //  O  no by 3 list of origin positions
          // Outputs:
          //  S  no by 1 list of winding numbers
          //
          // 3d

    writeMESH(...) method of builtins.PyCapsule instance
        writeMESH(*args, **kwargs)
        Overloaded function.

        1. writeMESH(mesh_file_name: str, V: List[List[float]], T: pyigl.VectorVectorInt, F: pyigl.VectorVectorInt) -> bool

        // save a tetrahedral volume mesh to a .mesh file
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be cast as double)
          //   Index  type for indices (will be cast to int)
          // Input:
          //   mesh_file_name  path of .mesh file
          //   V  double matrix of vertex positions  #V by 3
          //   T  #T list of tet indices into vertex positions
          //   F  #F list of face indices into vertex positions
          //
          // Known bugs: Holes and regions are not supported

        2. writeMESH(str: str, V: pyigl.eigen.MatrixXd, T: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi) -> bool

        // save a tetrahedral volume mesh to a .mesh file
          //
          // Templates:
          //   Scalar  type for positions and vectors (will be cast as double)
          //   Index  type for indices (will be cast to int)
          // Input:
          //   mesh_file_name  path of .mesh file
          //   V  double matrix of vertex positions  #V by 3
          //   T  #T list of tet indices into vertex positions
          //   F  #F list of face indices into vertex positions
          //
          // Known bugs: Holes and regions are not supported

    writeOBJ(...) method of builtins.PyCapsule instance
        writeOBJ(*args, **kwargs)
        Overloaded function.

        1. writeOBJ(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, CN: pyigl.eigen.MatrixXd, FN: pyigl.eigen.MatrixXi, TC: pyigl.eigen.MatrixXd, FTC: pyigl.eigen.MatrixXi) -> bool

        // Write a mesh in an ascii obj file
          // Inputs:
          //   str  path to outputfile
          //   V  #V by 3 mesh vertex positions
          //   F  #F by 3|4 mesh indices into V
          //   CN #CN by 3 normal vectors
          //   FN  #F by 3|4 corner normal indices into CN
          //   TC  #TC by 2|3 texture coordinates
          //   FTC #F by 3|4 corner texture coord indices into TC
          // Returns true on success, false on error
          //
          // Known issues: Horrifyingly, this does not have the same order of
          // parameters as readOBJ.

        2. writeOBJ(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi) -> bool

        // Write a mesh in an ascii obj file
          // Inputs:
          //   str  path to outputfile
          //   V  #V by 3 mesh vertex positions
          //   F  #F by 3|4 mesh indices into V
          //   CN #CN by 3 normal vectors
          //   FN  #F by 3|4 corner normal indices into CN
          //   TC  #TC by 2|3 texture coordinates
          //   FTC #F by 3|4 corner texture coord indices into TC
          // Returns true on success, false on error
          //
          // Known issues: Horrifyingly, this does not have the same order of
          // parameters as readOBJ.

    writePLY(...) method of builtins.PyCapsule instance
        writePLY(*args, **kwargs)
        Overloaded function.

        1. writePLY(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi, N: pyigl.eigen.MatrixXd, UV: pyigl.eigen.MatrixXd) -> bool

        // Write a mesh in an ascii ply file
          // Inputs:
          //   str  path to outputfile
          //   V  #V by 3 mesh vertex positions
          //   F  #F by 3 mesh indices into V
          //   N  #V by 3 normal vectors
          //   UV #V by 2 texture coordinates
          // Returns true on success, false on error

        2. writePLY(str: str, V: pyigl.eigen.MatrixXd, F: pyigl.eigen.MatrixXi) -> bool

        // Write a mesh in an ascii ply file
          // Inputs:
          //   str  path to outputfile
          //   V  #V by 3 mesh vertex positions
          //   F  #F by 3 mesh indices into V
          //   N  #V by 3 normal vectors
          //   UV #V by 2 texture coordinates
          // Returns true on success, false on error

DATA
    ARAP_ENERGY_TYPE_DEFAULT = ARAPEnergyType.ARAP_ENERGY_TYPE_DEFAULT
    ARAP_ENERGY_TYPE_ELEMENTS = ARAPEnergyType.ARAP_ENERGY_TYPE_ELEMENTS
    ARAP_ENERGY_TYPE_SPOKES = ARAPEnergyType.ARAP_ENERGY_TYPE_SPOKES
    ARAP_ENERGY_TYPE_SPOKES_AND_RIMS = ARAPEnergyType.ARAP_ENERGY_TYPE_SPO...
    EIGS_TYPE_LM = EigsType.EIGS_TYPE_LM
    EIGS_TYPE_SM = EigsType.EIGS_TYPE_SM
    MASSMATRIX_TYPE_BARYCENTRIC = MassMatrixType.MASSMATRIX_TYPE_BARYCENTR...
    MASSMATRIX_TYPE_DEFAULT = MassMatrixType.MASSMATRIX_TYPE_DEFAULT
    MASSMATRIX_TYPE_FULL = MassMatrixType.MASSMATRIX_TYPE_FULL
    MASSMATRIX_TYPE_VORONOI = MassMatrixType.MASSMATRIX_TYPE_VORONOI
    MESH_BOOLEAN_TYPE_INTERSECT = MeshBooleanType.MESH_BOOLEAN_TYPE_INTERS...
    MESH_BOOLEAN_TYPE_MINUS = MeshBooleanType.MESH_BOOLEAN_TYPE_MINUS
    MESH_BOOLEAN_TYPE_RESOLVE = MeshBooleanType.MESH_BOOLEAN_TYPE_RESOLVE
    MESH_BOOLEAN_TYPE_UNION = MeshBooleanType.MESH_BOOLEAN_TYPE_UNION
    MESH_BOOLEAN_TYPE_XOR = MeshBooleanType.MESH_BOOLEAN_TYPE_XOR
    NUM_ARAP_ENERGY_TYPES = ARAPEnergyType.NUM_ARAP_ENERGY_TYPES
    NUM_EIGS_TYPES = EigsType.NUM_EIGS_TYPES
    NUM_MASSMATRIX_TYPE = MassMatrixType.NUM_MASSMATRIX_TYPE
    NUM_MESH_BOOLEAN_TYPES = MeshBooleanType.NUM_MESH_BOOLEAN_TYPES
    NUM_PER_EDGE_NORMALS_WEIGHTING_TYPE = PerEdgeNormalsWeightingType.NUM_...
    NUM_PER_VERTEX_NORMALS_WEIGHTING_TYPE = PerVertexNormalsWeightingType....
    NUM_SIGNED_DISTANCE_TYPE = SignedDistanceType.NUM_SIGNED_DISTANCE_TYPE
    NUM_SOLVER_STATUSES = SolverStatus.NUM_SOLVER_STATUSES
    PER_EDGE_NORMALS_WEIGHTING_TYPE_AREA = PerEdgeNormalsWeightingType.PER...
    PER_EDGE_NORMALS_WEIGHTING_TYPE_DEFAULT = PerEdgeNormalsWeightingType....
    PER_EDGE_NORMALS_WEIGHTING_TYPE_UNIFORM = PerEdgeNormalsWeightingType....
    PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE = PerVertexNormalsWeightingTyp...
    PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA = PerVertexNormalsWeightingType...
    PER_VERTEX_NORMALS_WEIGHTING_TYPE_DEFAULT = PerVertexNormalsWeightingT...
    PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM = PerVertexNormalsWeightingT...
    SIGNED_DISTANCE_TYPE_DEFAULT = SignedDistanceType.SIGNED_DISTANCE_TYPE...
    SIGNED_DISTANCE_TYPE_PSEUDONORMAL = SignedDistanceType.SIGNED_DISTANCE...
    SIGNED_DISTANCE_TYPE_UNSIGNED = SignedDistanceType.SIGNED_DISTANCE_TYP...
    SIGNED_DISTANCE_TYPE_WINDING_NUMBER = SignedDistanceType.SIGNED_DISTAN...
    SOLVER_STATUS_CONVERGED = SolverStatus.SOLVER_STATUS_CONVERGED
    SOLVER_STATUS_ERROR = SolverStatus.SOLVER_STATUS_ERROR
    SOLVER_STATUS_MAX_ITER = SolverStatus.SOLVER_STATUS_MAX_ITER

FILE
    c:\code\myrepo\chbcapture\06_deformation\meshinterpolation\pyigl.pyd



Process finished with exit code -1
